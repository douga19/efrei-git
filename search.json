[
  {
    "objectID": "cours4.html",
    "href": "cours4.html",
    "title": "Cours 4 - Travailler avec un dépôt distant",
    "section": "",
    "text": "Git workflow"
  },
  {
    "objectID": "cours4.html#en-utilisant-git-clone",
    "href": "cours4.html#en-utilisant-git-clone",
    "title": "Cours 4 - Travailler avec un dépôt distant",
    "section": "4.1 En utilisant git clone",
    "text": "4.1 En utilisant git clone\ngit clone &lt;remote_url&gt;"
  },
  {
    "objectID": "cours4.html#en-ajoutant-un-dépôt-github-en-tant-que-dépôt-distant-dun-dépôt-local",
    "href": "cours4.html#en-ajoutant-un-dépôt-github-en-tant-que-dépôt-distant-dun-dépôt-local",
    "title": "Cours 4 - Travailler avec un dépôt distant",
    "section": "4.2 En ajoutant un dépôt Github en tant que dépôt distant d’un dépôt local",
    "text": "4.2 En ajoutant un dépôt Github en tant que dépôt distant d’un dépôt local\ncd &lt;path_to_your_local_repository&gt;\ngit remote add origin &lt;remote_url&gt;\ngit branch -M main # renomme la branche principale de votre dépôt local en \"main\"\ngit push origin main\n\n\n\n\n\n\nNote\n\n\n\n\nSi vous ajouter un dépôt distant à votre dépôt local, il faut vous assurez que votre historique est propre au moment de pousser (push) sur Github. Il faut absolument que le dépôt distant soit vide au moment du push si vous ne voulez pas gérer des conflits d’historique.\nVous trouverez&lt;remote_url&gt; sur la page Github du dépôt distant en cliquant sur le boutton &lt;&gt; Code, en choisissant ensuite l’option HTTPS.\n\n\n\n\n\n\nAccès à l’URL du dépôt distant"
  },
  {
    "objectID": "cours4.html#schéma-usuel-de-pour-une-collaboration-en-partant-dun-projet-vide",
    "href": "cours4.html#schéma-usuel-de-pour-une-collaboration-en-partant-dun-projet-vide",
    "title": "Cours 4 - Travailler avec un dépôt distant",
    "section": "5.1 Schéma usuel de pour une collaboration en partant d’un projet vide",
    "text": "5.1 Schéma usuel de pour une collaboration en partant d’un projet vide\nOn va supposer qu’Alice veuille se lancer dans le développement dans un nouveau projet avec Bob, et eventuellement Charles si celui-ci a du temps. Alice a récemment appris qu’il peuvent utiliser Git et Github pour travailler ensemble de manière propre et efficace. Voici alors le schéma usuel qu’ils vont suivre pour mettre en place leur projet et collaborer avec Git.\n\nAlice va créer un dépôt sur Github. Qui sera le dépôt distant de leur projet.\nComme elle a déjà commencé à faire des choses de son côté (elle a évidemment un dépôt local pour son projet), elle va ajouter le dépôt Github comme remote de son projet.\nAlice va ensuite pousser son historique sur le remote.\nBob et Charles peuvent désormais clone le dépôt distant pour récupérer chacun une copie du travail qu’Alice a déjà initié.\n\n\n\n\n\n\n\nWarning\n\n\n\ngit clone crée un nouveau dépôt, cette commande doit être réalisée à l’extérieur d’un dépôt Git.\n\n\n\nÀ ce stade chacun aura exactement la même copie du projet: état, historique, et adresse du remote (qui est ici origin).\nBob et Charles ont normalement accès en lecture au dépôt Github d’Alice, mais pas en écriture (c’est à dire que pour le moment ils ne peuvent pas encore pousser des nouveaux commits sur le dépôt distant).\nPour cela ils ont deux solutions:\n\nSoit Bob et Charles forkent le dépôt d’Alice, c’est à dire qu’ils en créée une copie sur leur compte Github (mais en l’appelant autrement que origin pour pouvoir différencier les deux remotes), et Alice fera de même pour que chacun puisse pousser des commits vers leur copie distante respectives et récupérer des commits depuis les remotes des autre;\nSoit Alice ajoute Bob et Charles comme membre du projet sur la Github et leur donne le droit d’écriture sur le dépôt.\n\n\nLa première approche, même si elle fonctionne, devient vite compliquée quand le nombre de collaborateur du groupe augmente, aussi, on va privilégier la seconde. Dès que vous aurez créé un dépôt vide sur Github, la plateforme va vous proposer d’y ajouter des collaborateur.\n\n\n\nAjout de collaborateurs sur Github\n\n\n\n\n\n\n\n\nNote\n\n\n\nCela peut également se faire via l’onglet Settings du dépôt GitHub si le dépôt existe déjà.\n\n\n\n\n\nConfiguration des collaborateurs via Settings\n\n\n\nAlice va donc ajouter Bob et Charles comme collaborateur sur son dépôt Github.\n\nÇa y est tout est mis en place pour que chacun puisse désormais travailler sur une même base commune du projet."
  },
  {
    "objectID": "cours4.html#issues-et-pull-request",
    "href": "cours4.html#issues-et-pull-request",
    "title": "Cours 4 - Travailler avec un dépôt distant",
    "section": "5.2 Issues et Pull request",
    "text": "5.2 Issues et Pull request\nGithub propose également des fonctionnalités qui permettent de faciliter le travail collaboratif. Dans un dépôt Github, il est possible de créer des issues et des pull request.\n\nUne issue est une fonctionnalité de Github qui permet de créer des tickets pour signaler des bugs, demander des fonctionnalités ou poser des questions. Cela permet de garder une trace de tout ce qui se passe sur le projet et de pouvoir y revenir plus tard si besoin.\nUne pull request est une demande de fusion de code. C’est une fonctionnalité de Github qui permet de faire une revue de code avant de fusionner une branche avec la branche principale du projet. Cela permet de s’assurer que tout est bon avant de fusionner une branche avec la branche principale du projet.\n\nLe petit schéma ci-dessous résume le processus de pull request.\n\n\n\nAn overview of pull-request mechanism in GitHub\n\n\nSource: learn github"
  },
  {
    "objectID": "cours4.html#bonnes-pratiques",
    "href": "cours4.html#bonnes-pratiques",
    "title": "Cours 4 - Travailler avec un dépôt distant",
    "section": "5.3 Bonnes pratiques",
    "text": "5.3 Bonnes pratiques\nÀ partir de là, vous devriez être capables de travailler en même temps sur un projet. Cependant, il y a quelques bonnes pratiques à respecter pour que tout se passe bien.\n\nAvant de commencer à travailler sur un projet, il faut toujours pull les dernières modifications du dépôt distant pour être sûr d’avoir la dernière version du projet. Cela évite les conflits et les problèmes de synchronisation.\nIl faut toujours travailler sur une branche différente de la branche principale du projet. Cela permet de ne pas modifier le code principal du projet et de pouvoir tester des choses sans risquer de casser le code principal. Cela permet également de pouvoir travailler sur plusieurs fonctionnalités en même temps sans que cela ne pose de problème.\nUne fois que vous avez terminé de travailler sur une fonctionnalité, il faut push votre branche sur le dépôt distant et créer une pull request pour demander à ce que votre code soit intégré au code principal du projet. Cela permet de faire une revue de code et de s’assurer que tout est bon avant de fusionner votre branche avec la branche principale du projet.\nUne fois que votre branche a été fusionnée avec la branche principale du projet, il faut supprimer votre branche pour éviter d’avoir trop de branches inutiles sur le dépôt distant."
  },
  {
    "objectID": "cours2.html",
    "href": "cours2.html",
    "title": "Cours 2 - L’historique des commits",
    "section": "",
    "text": "À partir de maintenant, et pour tout le reste du cours, nous allons travailler avec Git. Nous allons aborder dans ce chapitre l’historique des commits de la manière dont Git le voit. Dans ce cours nous allons voir comment explorer l’historique des commits, comment modifier l’historique des commits, comment annuler des modifications, etc."
  },
  {
    "objectID": "cours2.html#éléments-de-lhistorique-des-commits",
    "href": "cours2.html#éléments-de-lhistorique-des-commits",
    "title": "Cours 2 - L’historique des commits",
    "section": "1 Éléments de l’historique des commits",
    "text": "1 Éléments de l’historique des commits\n\n1.1 Commit\n\n\n\n\n\n\nDéfinition\n\n\n\nDans le contexte du versionnage, un commit est tout simplement une version de notre projet. C’est une sauvegarde de l’état de notre projet à un moment donné. Vous pouvez voir un commit comme une photo (snapshot) de votre projet à un instant T (à l’instant où le commit a été créé).\n\n\nDans Git, un commit est une structure de données qui contient plusieurs informations dont:\n\ndes métadonnées (identifiant ou hash, auteur, date, message, )\nune référence vers un ou plusieurs commits parents\nune copie de l’arborescence du projet au moment du commit\n\nLa commande git commit permet donc de créer un nouveau commit et de l’apposer au bon endroit sur le graphe des commits.\nAnalysons donc le résultat d’un git log dans un dépôt après un premier commit. Nous allons afficher le numéro de ligne pour pouvoir se repérer plus facilement.\n\n\nExemple de résultat de git log\n\n$ git log\ncommit 5be88b053a645728062548258ecbf531aadbcb95 (HEAD -&gt; main)\nAuthor: Linus Torvalds &lt;torvalds@mail.com&gt;\nDate:   Wed Jan 10 10:50:22 2024 +0100\n\n    Initial commit\n\nVoyons ces informations à la loupe:\n\nÀ la ligne 2, on retrouve une longue chaîne de caractères : 5be88b053a645728062548258ecbf531aadbcb95 qui indique le hash ou l’identifiant du commit (c’est un identifiant unique du commit). Git le génère en utilisant l’algorithme SHA-1.\nPuis juste après (HEAD -&gt; main). Nous allons voir plus tard ce que cela signifie.\nÀ la ligne 3 nous avons les informations sur l’auteur du commit Author: Linus Torvalds &lt;torvalds@mail.com&gt;.\nPuis à la ligne 4, Date:   Wed Jan 10 10:50:22 2024 +0100, on nous indique la date à laquelle le commit a été créé, c’est-à-dire que ce commit sauvegarde l’état de notre dépôt à ce moment précis.\nEnfin à la ligne 6, la chaîne de caractères Initial commit indique le message associé à ce commit. Généralement il faut bien décrire les changements apportés dans ce commit pour pouvoir facilement se repérer dans l’historique.\n\n\n\n1.2 Branche\n\n\n\n\n\n\nDéfinition\n\n\n\nUne branche est une ligne de développement indépendante. C’est une suite de commits qui se suivent et qui ont un point commun : ils ont tous été créés à partir du même commit. C’est-à-dire que tous les commits d’une branche ont un ancêtre commun.\n\n\nOn ne peut pas parler de l’historique des commits sans parler de branches. Nous avons vu que l’historique des commits est un graphe dont les sommets sont des commits. Quand on créé une nouvelle branche, nous créons un point de divergence au niveau dernier commit. C’est-à-dire que les commits suivants vont prendre des chemins différents selon la branche dans laquelle ils appartiennent.\n\n\n\n\n\n\nNote\n\n\n\nDans Git, une branche est une pointeur vers un commit. Ou si vous préférez, une branche est une étiquette qui référence un commit.\n\n\nNous allons parler en détail des branches dans le prochain chapitre. Pour l’instant, nous allons juste voir comment Git représente les branches dans l’historique des commits.\nNous sommes alors en mesure de comprendre la ligne\ncommit 5be88b053a645728062548258ecbf531aadbcb95 (HEAD -&gt; main)\ndu git log précédent: main référence le commit dont le hash est 5be88b053a645728062548258ecbf531aadbcb95. C’est-à-dire que main est une branche qui pointe sur le commit 5be88b053a645728062548258ecbf531aadbcb95.\n\n\n1.3 HEAD\n\n\n\n\n\n\nNote\n\n\n\nHEAD est une référence spéciale qui référence le commit qui sera le parent du prochain commit. Généralement elle pointe sur la branche courante dans laquelle on se trouve (car on peut la déplacer).\n\n\nDonc, en reprenant le résultat de notre git log:\n\n\nExemple de résultat de git log\n\n$ git log\ncommit 5be88b053a645728062548258ecbf531aadbcb95 (HEAD -&gt; main)\nAuthor: Linus Torvalds &lt;torvalds@mail.com&gt;\nDate:   Wed Jan 10 10:50:22 2024 +0100\n\n    Initial commit\n\nOn sait que le prochain commit aura comme parent le commit dont le message est \"Initial commit\". Supposons maintenant que nous apportons des modifications à notre dépôt et que nous procédons ensuite à un commit. Le résultat du git log va alors ressembler à quelque chose comme ceci.\n\n\nExemple de résultat de git log après un deuxième commit\n\ncommit fe89c631555f9c8168ed0ded9956f68a536d2c82 (HEAD -&gt; main)\nAuthor: Linus Torvalds &lt;torvalds@mail.com&gt;\nDate:   Wed Jan 10 10:55:13 2024 +0100\n\n    Set up ci.yml\n\ncommit 5be88b053a645728062548258ecbf531aadbcb95\nAuthor: Linus Torvalds &lt;torvalds@mail.com&gt;\nDate:   Wed Jan 10 10:50:22 2024 +0100\n\n    Initial commit\n\nHEAD et main référencent désormais le dernier commit. Nous en verrons d’avantage lors du cours sur les branches.\n\n\n\n\n\n\nRéférence relative à HEAD\n\n\n\nOn peut utiliser la référence relative à HEAD pour désigner un commit. Pour rappel, HEAD est une référence qui pointe sur le commit qui sera le parent du prochain commit.\nPar exemple, pour désigner le commit précédent, on peut utiliser HEAD^. Pour le précédent commit du précédent commit, on peut utiliser HEAD^^ et ainsi de suite. On peut également utiliser HEAD~n pour désigner le n-ième commit précédent.\n\n\n\n\n1.4 Références à un commit\nPour désigner un commit, on peut utiliser son hash. Toutefois il n’est pas pratique de retenir les hash des commits.\n\nGit nous permet dans un premier temps de n’utiliser que les premiers caractères du hash pour désigner un commit. Par exemple, pour désigner le commit 5be88b053a645728062548258ecbf531aadbcb95, on peut utiliser 5be88b0. Git va alors chercher le commit qui commence par 5be88b0 et qui est le plus récent.\nOn peut également utiliser les références relatives à HEAD comme nous l’avons vu précédemment.\nIl existe également les tag qui sont des références qui pointent sur un commit spécifique. Nous en parlerons plus tard dans le TP associé à ce cours."
  },
  {
    "objectID": "cours2.html#explorer-et-modifier-lhistorique-des-commits",
    "href": "cours2.html#explorer-et-modifier-lhistorique-des-commits",
    "title": "Cours 2 - L’historique des commits",
    "section": "2 Explorer et modifier l’historique des commits",
    "text": "2 Explorer et modifier l’historique des commits\nGit offre plusieurs manières pour explorer et modifier l’historique des commits. De manière générale, nous voulons nous déplacer dans l’historique des commits pour soit revenir à un état antérieur de notre projet soit pour annuler des modifications.\nLes principales commandes à notre disposition sont les commandes git reset, git checkout et git revert. Toutes vous permettent d’annuler certains types de changement dans votre dépôt. De plus, on peut utiliser les deux premières pour gérer des commits ou des fichiers individuels.\nComme elles sont très similaires, veillez à ne pas les confondre : à chaque scénario sa commande !. Nous allons comparer les scénarios d’utilisation les plus courantes de git reset, git checkout et git revert.\nVoyons donc en détail l’effet qu’on chacune de ces commandes. Nous allons prendre le graphe des commits suivant comme exemple:\nC0 &lt;- C1 &lt;- C2 &lt;- main &lt;- HEAD\n\n\n\n\n\n\nNote\n\n\n\nIci C0, C1 et C2 dénotent les hash des commits.\n\n\n\n2.1 1. git checkout\n\n\n\n\n\n\nCommande\n\n\n\ngit checkout permet de déplacer HEAD vers un commit spécifique. C’est-à-dire que HEAD va pointer sur le commit spécifié.\n\n\ngit checkout permet de déplacer HEAD vers un commit spécifique. Elle peut prendre en paramètre un le hash d’un commit, une branche ou un tag. Elle peut également être utilisée dans un périmètre de fichier, c’est-à-dire qu’on peut l’appliquer au niveau d’un certains nombre de fichiers pour que les versions de ces fichiers correspondent à celles d’un commit spécifique. Par exemple,\n\nLa commande git checkout C0 a pour effet:\n\nHEAD\n |\n v\nC0 &lt;- C1 &lt;- C2 &lt;- main\n\nTandis que la commande:\n\ngit checkout C1 toto.py readme.md\nva restaurer les fichiers toto.py et readme.md de la branche main à leur version au moment du commit C1.\n\n\n2.2 2. git reset\n\n\n\n\n\n\nCommande\n\n\n\ngit reset permet de déplacer la branche courante (HEAD) et les pointeurs de branche vers un commit spécifique. Elle est généralement utilisée pour annuler ou réorganiser les commits dans l’historique.\n\n\nIl existe trois formes principales de git reset et qui s’utilisent avec les options suivantes:\n\ngit reset --soft &lt;référence à un commit&gt; :\n\ndéplace HEAD et la branche courante au commit spécifié\nconserve les modifications dans la zone d’index\npréserve les modifications dans le répertoire de travail.\nutile lorsqu’on veut modifier son dernier commit\n\ngit reset --mixed &lt;référence à un commit&gt; : (par défaut)\n\ndéplace HEAD et la branche courante au commit spécifié\nréinitialise la zone d’index\npréserve les modifications dans le répertoire de travail.\nutile lorsqu’on veut combiner plusieurs commits, ou réorganiser les changements avant de committer à nouveau\n\ngit reset --hard &lt;référence à un commit&gt; : Annule les commits en réinitialisant à la fois la zone d’index et le répertoire de travail à l’état du commit spécifié. Toutes les modifications non validées sont perdues.\n\n\n\n\n\n\n\nAttention\n\n\n\n\nSans spécifier d’option, git reset utilise l’option --mixed par défaut.\nIl est important de noter que git reset modifie l’historique des commits, il est donc recommandé de ne pas l’utiliser sur des commits déjà partagés avec d’autres utilisateurs (À ne pas faire sur une branche distante).\ngit reset --hard peut vous faire perdre vos modifications\n\n\n\nSur notre graphe exemple, git reset C1 aura pour effet:\nC0 &lt;- C1 &lt;- main &lt;- HEAD\n\n\n2.3 3. git revert\n\n\n\n\n\n\nCommande\n\n\n\ngit revert permet d’annuler un commit spécifique en créant un nouveau commit qui annule les modifications apportées par le commit précédent. Contrairement à git reset, git revert ne modifie pas l’historique des commits existants, mais ajoute plutôt un nouveau commit qui annule les modifications spécifiées.\n\n\nLorsque vous exécutez git revert &lt;référence à un commit&gt;, Git crée un nouveau commit contenant l’inverse des modifications apportées par le commit spécifié. Cela signifie que les modifications initiales restent dans l’historique, mais elles sont neutralisées par le nouveau commit de réversion.\nL’avantage de git revert est qu’il est sûr à utiliser sur des commits déjà partagés, car il n’altère pas l’historique existant. Cependant, il peut entraîner un historique de commits plus complexe avec des commits de réversion supplémentaires.\nPar exemple, git revert C2 créera donc un commit C3 qui va neutraliser les modifications apportées par C2. Cette commande aura donc comme effet:\nC0 &lt;- C1 &lt;- C2 &lt;- C3 &lt;- main &lt;- HEAD\n                  *           \n            (C3 annule C2)\n\n\n\n\n\n\nEn somme\n\n\n\n\nUn checkout est une opération qui permet de déplacerHEAD vers un commit spécifique.\nUn reset est une opération qui prend un commit spécifique et réinitialise les zones de travail de sorte qu’elles correspondent à l’état du dépôt au niveau du commit spécifique. Un reset peut être appelé dans trois modes différents.\nUn revert est une opération qui prend un commit spécifique et crée un nouveau commit qui inverse le commit spécifique."
  },
  {
    "objectID": "tp4.html",
    "href": "tp4.html",
    "title": "TP4 - Programming quotes (collaborer sur GitHub)",
    "section": "",
    "text": "Lors de ce TP, votre groupe est missionné pour développer une petit programme python qui permet de générer des citations aléatoires. Ce TP vous permettra de vous familiariser avec les fonctionnalités de base ainsi que les bonnes pratiques de la collaboration sur GitHub en utilisant des branches."
  },
  {
    "objectID": "tp4.html#partie-1-préliminaires",
    "href": "tp4.html#partie-1-préliminaires",
    "title": "TP4 - Programming quotes (collaborer sur GitHub)",
    "section": "1 Partie 1: Préliminaires",
    "text": "1 Partie 1: Préliminaires\n\n1.1 Dans Github\n\nL’initiateur crée un dépôt privé sur son compte Github dont le nom sera quotes-nom-groupe. Par exemple si l’initiateur est l’étudiant FOO Bar du groupe B, le nom de son dépôt sera quotes-foo-b. Ce dépôt sera le dépôt principal du TP.\nL’initiateur ajoutera:\n\nSon enseignant de TP en tant que collaborator du dépôt\nTous les membres du groupe en tant que collaborators du dépôt avec les droits d’écriture\n\nChaque contributeur-i clone le dépôt sur sa machine locale:\n\ngit clone https://github.com/[nom-initiateur]/quotes-foo-b.git\n\nLe dépôt doit absolument avoir un fichier README.md dans lequel on retrouvera:\n\nLes noms et prénoms de chaque membre de l’équipe, ainsi que votre groupe\nLes rôles qu’ont pris chaque membre du groupe durant la réalisation du TP\nLes branches de fonctionnalités sur lesquelles travaille chaque contributeur\n\n\nVoici un exemple de README:\n# Programming Quote Generator\n\nA python program that generates programming quotes and jokes.\n\n## Contributors\n- `initiator`: FOO Bar Group B\n- `contributor-1`: BAR Foo Group B\n- `contributor-2`: WIZZ Bang B \n- `contributor-3`: TOTO Titi Group B \n\n## Feature Branches\n- `contributor-1`: feature/add-quote\n- `contributor-2`: feature/display-quotes\n- `contributor-3`: feature/string-inputs\n\n\n1.2 Sur votre machine\n\nPour une meilleure lisibilité de l’historique Git, vous pourrez configurer un alias pour votre git log:\n\ngit config --global alias.hist \"log --pretty=format:'%h %ad | %s%d [%an]' --all --graph --date=short\"\n\nChaque contributeur travaillera sur sa propre branche de fonctionnalité. Pour créer et basculer sur une nouvelle branche:\n\ngit checkout -b feature/nom-fonctionnalite\n\n\nPour vérifier sur quelle branche vous vous trouvez:\n\ngit branch\n\nPour basculer sur une branche existante:\n\ngit checkout nom-branche\n\nPour mettre à jour votre branche locale avec les dernières modifications de main:\n\ngit checkout main\ngit pull\ngit checkout votre-branche\ngit merge main"
  },
  {
    "objectID": "tp4.html#partie-2-initialisation-du-dépôt",
    "href": "tp4.html#partie-2-initialisation-du-dépôt",
    "title": "TP4 - Programming quotes (collaborer sur GitHub)",
    "section": "2 Partie 2: Initialisation du dépôt",
    "text": "2 Partie 2: Initialisation du dépôt\nL’initiateur ajoutera les fichiers quotes.txt, functions.py et main.py sur la branche main dont les contenus initiaux sont les suivants:\nquotes.txt:\n\n\nquotes.txt\n\nProgrammer - An organism that turns caffeine into code\nWhy do programmers prefer dark mode? Because light attracts bugs.\nIf debugging is the process of removing software bugs, then programming must be the process of putting them in.\nI don't always test my code, but when I do, I do it in production.\nWhy do programmers always mix up Christmas and Halloween? Because Oct 31 == Dec 25!\nWhy did the programmer quit his job? Because he didn't get arrays.\nWhy do programmers prefer iOS development? Because the Swift.\nWhy do programmers prefer dogs over cats? Because dogs have fetch and cats have catch.\nWhy do programmers hate nature? It has too many bugs.\nThere are only 10 types of people in the world: Those who understand binary and those who don't.\nWhy did the programmer go broke? Because he lost his domain in a bet.\nWhy don't programmers like to go outside? The sunlight causes too many reflections.\nWhy did the programmer get stuck in the shower? The instructions said: Lather, Rinse, Repeat.\nWhy do programmers prefer dark chocolate? Because it's byte-sized!\nWhy did the programmer bring a ladder to the bar? They heard the drinks were on the house.\n\n\n\nfunctions.py\n\nimport random\n\ndef load_quotes(filename):\n    quotes = []\n    with open(filename, 'r') as file:\n        lines = file.readlines()\n    for line in lines:\n        line = line.strip()\n        if line:\n            quotes.append(line)\n    return quotes\n\ndef random_quote(quotes):\n    random_quote = random.choice(quotes)\n    return random_quote\n\ndef print_quote(quote):\n    print(quote)\n\ndef view_quotes(quotes):\n    for quote in quotes:\n        print_quote(quote)\n\n\n\nmain.py\n\nfrom functions import *\n\ndef menu():\n    print(\"\\n==== Programming Quotes ====\")\n    print(\"1. Random quote\")\n    print(\"2. All quotes\")\n    print(\"3. Exit\")\n\ndef main():\n    while True:\n        quotes = load_quotes(\"quotes.txt\")\n        menu()\n\n        choice = input(\"Choose your an action (1-3): \")\n        \n        if choice == \"1\":\n            print_quote(random_quote(quotes))\n        elif choice == \"2\":\n            view_quotes(quotes)\n        elif choice == \"3\":\n            print(\"Good bye...\")\n            break\n        else:\n            print(\"Invalid input\")\n\nif __name__ == \"__main__\":\n    main()\n\n\nCette version doit être taguée comme version-1.0."
  },
  {
    "objectID": "tp4.html#partie-3-ajout-de-fonctionnalités",
    "href": "tp4.html#partie-3-ajout-de-fonctionnalités",
    "title": "TP4 - Programming quotes (collaborer sur GitHub)",
    "section": "3 Partie 3: Ajout de fonctionnalités",
    "text": "3 Partie 3: Ajout de fonctionnalités\n\n3.1 Fonctionnalité add-quote\nLe contributeur-1 créera une branche feature/add-quote et implémentera une fonctionnalité add_quote() qui permet d’ajouter une citation dans l’application. Pour cela voici les modifications qu’il doit apporter:\nfunctions.py: ajout d’une fonction add_quote()\ndef add_quote(quotes, filename):\n    new_quote = input(\"Enter a new quote: \")\n    quotes.append(new_quote)\n    \n    with open(filename, 'a') as file:\n        file.write(new_quote)\nmain.py: modification de menu() ainsi que de main() pour intégrer la fonction add_quote().\n\nUne fois que vous avez testé et vérifié le code: 1. Committez vos changements 2. Poussez votre branche sur GitHub:\ngit push origin feature/add-quote\n\nCréez une Pull Request depuis feature/add-quote vers main\n\n\n\n\n3.2 Fonctionnalité display-quotes\nLe contributeur-2 créera une branche feature/display-quotes et implémentera une fonctionnalité display_quotes() qui permet d’afficher un certain nombre de citations à la fois. Cette fonctionnalité va remplacer l’option “All quotes” du menu. Pour cela voici les modifications qu’il doit apporter:\nfunctions.py: ajout d’une fonction display_quotes()\ndef display_quotes(quotes, count):\n    if count &gt;= len(quotes):\n        print(\"All Quotes:\")\n        view_quotes(quotes)\n    else:\n        print(f\"First {count} Quotes:\")\n        for i in range(count):\n            print_quote(quotes[i])\nmain.py: modification de menu() ainsi que de main() pour intégrer la fonction display_quotes(). Notez que display_quote() attend le paramètre count que vous devez donc demander à l’utilisateur. Une manière de le faire est par exemple:\nelif choice == \"2\": # gestion de display_quotes()\n    count = int(input(\"Enter the number of quotes to display: \"))\n    display_quotes(quotes, count)\n\nUne fois que vous avez testé et vérifié le code: 1. Committez vos changements 2. Poussez votre branche sur GitHub:\ngit push origin feature/display-quotes\n\nCréez une Pull Request depuis feature/display-quotes vers main\n\n\n\nUne fois les deux fonctionnalités précédentes fusionnées dans main, la version sera taguée comme version-1.1"
  },
  {
    "objectID": "tp4.html#partie-4-modifications-des-inputs",
    "href": "tp4.html#partie-4-modifications-des-inputs",
    "title": "TP4 - Programming quotes (collaborer sur GitHub)",
    "section": "4 Partie 4 : Modifications des inputs",
    "text": "4 Partie 4 : Modifications des inputs\nLe contributeur-3 créera une branche feature/string-inputs à partir de main et modifiera la version-1.1 du programme de telle sorte que les inputs de l’utilisateur soient désormais une chaîne de caractères en lieu et en place d’un entier pour le choix de l’action à effectuer.\nSeul le fichier main.py sera modifié:\n\n\nmain.py\n\nfrom functions import *\n\ndef menu():\n    print(\"\\n==== Programming Quotes ====\")\n    print(\"random : Random quote\")\n    print(\"display : Display quotes\")\n    print(\"add : Add a new quote\")\n    print(\"exit : Exit the program\")\n\ndef main():\n    while True:\n        quotes = load_quotes(\"quotes.txt\")\n        menu()\n\n        choice = input(\"&gt;&gt; \")\n        \n        if choice == \"random\":\n            print_quote(random_quote(quotes))\n        elif choice == \"display\":\n            count = int(input(\"Enter the number of quotes to display: \"))\n            display_quotes(quotes, count)\n        elif choice == \"add\":\n            add_quote(quotes, \"quotes.txt\")\n        elif choice == \"exit\":\n            print(\"Good bye...\")\n            break\n        else:\n            print(\"Invalid input\")\n\nif __name__ == \"__main__\":\n    main()\n\n\nUne fois que vous avez testé et vérifié le code: 1. Committez vos changements 2. Poussez votre branche sur GitHub:\ngit push origin feature/string-inputs\n\nCréez une Pull Request depuis feature/string-inputs vers main\n\n\n\nUne fois le programme modifié et la Pull Request fusionnée dans main, la version sera taguée comme version-2.0"
  },
  {
    "objectID": "tp4.html#bonnes-pratiques-pour-les-branches",
    "href": "tp4.html#bonnes-pratiques-pour-les-branches",
    "title": "TP4 - Programming quotes (collaborer sur GitHub)",
    "section": "5 Bonnes pratiques pour les branches",
    "text": "5 Bonnes pratiques pour les branches\n\nCréez des branches à partir de la dernière version de main\nDonnez des noms descriptifs à vos branches (ex: feature/add-quote)\nGardez vos branches à jour en fusionnant régulièrement les changements de main\nSupprimez les branches une fois qu’elles sont fusionnées"
  },
  {
    "objectID": "tp2.html",
    "href": "tp2.html",
    "title": "TP2 - Explorer l’historique des commits, annuler des modifications",
    "section": "",
    "text": "Dans le répertoire xcs310 créez un répertoire tp2 et initialisez-y un dépôt git vide. Lors de ce TP nous allons travailler avec le dépôt tp2. Pour ce faire nous allons écrire un petit programme python qui fera office d’une petite calulatrice basique.\nAssurez-vous que vous êtes bien à la racine du répertoire tp2 puis créez un fichier reponses.md dans lequel vous répondrez aux questions de ce TP. Créez également un fichier .gitignore et faîtes en sorte que Git ignore le fichier reponses.md pour le moment.\n\n\n\n\n\n\n\nIndication\n\n\n\nNotez au fur et à mesure vos réponses dans le fichier reponses.md. Vous pouvez également y noter les commandes que nous utiliserons dans ce TP.\n\n\n\nToujours dans le répertoire tp2, créez deux fichiers operation.py et calc.py qui contiendront respectivement les lignes de python ci-après.\n\n\noperation.py\n\ndef add(a, b):\n    return a + b\n\ndef subtract(a, b):\n    return a - b\n\ndef multiply(a, b):\n    return a * b\n\n\n\ncalc.py\n\nfrom operation import *\n\nif __name__ == \"__main__\":\n    while True:\n        input_str = input(\"Enter the calculation (in the format 'num1 operation num2', or 'exit' to exit): \")\n\n        if input_str == \"exit\":\n            break\n\n        num1, operation, num2 = input_str.split()\n        num1 = int(num1)\n        num2 = int(num2)\n\n        if operation == '+':\n            print(num1, \"+\", num2, \"=\", add(num1, num2))\n        elif operation == '-':\n            print(num1, \"-\", num2, \"=\", subtract(num1, num2))\n        elif operation == '*':\n            print(num1, \"*\", num2, \"=\", multiply(num1, num2))\n        else:\n            print(\"Invalid operation\")\n\nObservez le contenu des deux fichiers précédents. Vous devrez être en mesure de comprendre le fonctionnement de notre calculatrice. Exécutez le fichier calc.py pour vous assurer que tout fonctionne correctement.\nAjoutez une ligne dans le fichier .gitignore pour ignorer le répertoire __pycache__.\nAjoutez tous les nouveaux fichiers à la zone d’index, puis créez un commit avec le message \"Initial commit\".\nVisualisez l’historique des commits avec la commande git log. Vous devriez voir apparaître le commit que vous venez de créer. Copiez ensuite la réponse de votre git log dans reponse.md.\n\n\n\n\n\n\n\nWarning\n\n\n\nPensez à mettre un petit commentaire contenant le numéro de la question pour chaque réponse dans le fichier reponses.md.\n\n\n\nNous allons désormais taguer cette version de notre programme. Pour ce faire, créez un tag v1.0 sur le dernier commit avec la commande:\n$ git tag v1.0\nRegardez à nouveau l’historique des commits avec la commande git log. Vous devriez voir apparaître le tag que vous venez de créer. Copiez ensuite la réponse de votre git log dans reponse.md. Quelles différences remarquez vous entre ce log et celui de la question 7 ?\n\n\n\n\n\nNous allons désormais ajouter une nouvelle fonctionnalité à notre calculatrice. Pour ce faire, ajoutez les lignes de code suivantes à la fin du fichier operation.py:\n\n\noperation.py\n\ndef divide(a, b):\n    return a / b\n\nModifiez ensuite le fichier calc.py pour prendre en compte cette nouvelle fonctionnalité: ajoutez les lignes de code suivantes après la ligne 20 du fichier calc.py:\n\n\ncalc.py\n\nelif operation == '/':\n    print(num1, \"/\", num2, \"=\", divide(num1, num2))\n\nExécutez à nouveau le fichier calc.py pour vous assurer que tout fonctionne correctement. Une fois que c’est le cas, ajoutez tous les fichiers modifiés à la zone d’index, puis créez un commit avec le message \"Add divide function\".\nVisualisez l’historique des commits avec la commande git log. Vous devriez voir apparaître le commit que vous venez de créer. Copiez ensuite la réponse de votre git log dans reponse.md.\nComparez alors votre dernier log avec celui de la question 9 de l’exercice précédent. Que remarquez-vous ? Déduire le rôle de la référence HEAD dans Git ainsi que le rôle des tags.\n\n\n\n\n\nLa commande git log permet d’afficher l’historique des commits. Cependant, il est possible de condenser cet historique en affichant uniquement les informations essentielles de chaque commit. Testez alors les commandes suivantes et observez leurs différences:\n$ git log --all\n$ git log --decorate\n$ git log --oneline\n$ git log --graph\nCopiez ensuite les réponses de ces log dans reponse.md.\nEssayez maintenant de combiner ces commandes pour afficher un historique condensé. Copiez ensuite la réponse de votre git log dans reponse.md. Puis testez enfin la commande suivante:\n$ git log --all --decorate --oneline --graph\nNotez également réponse de cette commande dans reponse.md.\nGit permet de créer ce que l’on appelle des alias. Ces alias permettent de créer des commandes personnalisées. Par exemple, nous pouvons créer un alias git adog qui affichera l’historique des commits de manière condensée (adog pour all, decorate, oneline, graph). Pour ce faire, exécutez la commande suivante:\n$ git config --global alias.adog \"log --all --decorate --oneline --graph\"\nTestez ensuite votre nouvel alias avec la commande git adog. Désormais, vous pouvez utiliser git adog à la place de git log --all --decorate --oneline --graph.\n\n\n\n\n\nAïe! Nous venons de nous rendre compte que notre fonction divide ne fonctionne pas correctement. En effet, si on divise par 0, notre programme plante.\n\n\n\n\n\n\n\nAttention\n\n\n\nCes modifications ne sont pas encore à faire tout de suite! Nous allons d’abord créer des branches pour pouvoir travailler dessus.\n\n\nNous allons résoudre ce problème de la division par 0 en modifiant la fonction divide comme suit:\n\n\noperation.py\n\ndef divide(a, b):\n    try:\n        return a / b\n    except ZeroDivisionError:\n        print(\"Division by zero is not allowed\")\n        return None\n\net en modifiant le fichier calc.py comme suit à partir de la ligne 20:\n\n\ncalc.py\n\nelif operation == '/':\n    result = divide(num1, num2)\n    if result is not None:\n        print(num1, \"/\", num2, \"=\", result)\n\n\nNous allons effectuer la correction de notre programme de trois manières différentes: une avec la commande git checkout, une avec la commande git reset et une dernière avec la commande git revert. Pour ce faire, nous allons créer trois branches différentes. Créez alors une branche fix-checkout, une branche fix-reset et une branche fix-revert avec les commandes suivantes:\n$ git branch fix-checkout\n$ git branch fix-reset\n$ git branch fix-revert\nVisualisez l’historique de votre dépôt grâce à la commande git adog pour vérifier que les trois branches que nous avons créées sont bien présentes et se situent toutes sur le même commit. Copiez ensuite la réponse de votre git adog dans reponse.md.\n\n\n\n\n\nPlacez-vous dans la branche fix-checkout avec la commande suivante:\n$ git checkout fix-checkout\nVous devriez voir apparaître le message suivant:\nSwitched to branch 'fix-checkout' # ou l'équivalent en français :)\nVisualisez alors le log de votre dépôt grâce à la commande git adog. Dans la réponse de la commande, quelle information vous permet de vérifier que vous vous trouvez bien sur la branche fix-checkout ?\nLa dernière version stable de notre programme est la version taguée v1.0. Nous voudrions alors que les fichiers calc.py et operation.py retrouvent leur état de la version v1.0. Exécutez alors la commande suivante:\n$ git checkout v1.0 calc.py operation.py\nOuvrez ensuite les fichiers calc.py et operation.py et vérifiez que les modifications que vous avez apportées dans l’exercice 2 ont bien été annulées, c’est-à-dire que notre calculatrice ne gère plus l’opération de division.\nModifiez ensuite les fichiers calc.py et operation.py pour corriger le problème de la division par 0 comme indiqué dans l’exercice 4. Testez ensuite le programme pour vérifier que tout fonctionne correctement.\nUne fois que c’est fait, ajoutez les fichiers modifiés à la zone d’index, puis créez un commit avec le message \"Fix divide function with git checkout\".\nVisualisez l’historique des commits avec la commande git adog. Vous devriez voir apparaître le commit que vous venez de créer. Copiez ensuite la réponse de votre git adog dans reponse.md.\n\n\n\n\n\nPlacez-vous dans la branche fix-reset avec la commande suivante:\n$ git checkout fix-reset\nVous devriez voir apparaître le message suivant:\nSwitched to branch 'fix-reset' # ou l'équivalent en français :)\nVisualisez alors le log de votre dépôt grâce à la commande git log. Dans le log, quelle information vous permet de vérifier que vous vous trouvez bien sur la branche fix-reset ?\nEffectuez un git status pour vérifier l’état de notre dépôt. Y-a-t-il des fichiers modifiés ? Y-a-t’il des modifications en attente de validation ?\nOn souhaite maintenant annuler les modifications apportées dans l’exercice 2. Pour ce faire, exécutez la commande suivante:\n$ git reset --hard HEAD~1\nCette commande permet de revenir au commit précédent en annulant toutes les modifications apportées depuis le dernier commit.\nObservez que les modifications apportées dans l’exercice 2 ont bien été annulées. C’est-à-dire que notre calculatrice ne gère plus l’opération de division et que nous sommes retournés à la version taguée v1.0. Vérifiez ceci en effectuant un git log et que le HEAD et la branche fix-reset pointent bien tous les deux sur le commit tagué v1.0.\nCorriger ensuite le problème de la division par 0 comme indiqué dans l’exercice 4. Testez ensuite le programme pour vérifier que tout fonctionne correctement.\nUne fois que c’est fait, ajoutez les fichiers modifiés à la zone d’index, puis créez un commit avec le message \"Fix divide function with git reset\".\nVisualisez l’historique des commits avec la commande git adog. Vous devriez voir apparaître le commit que vous venez de créer. Copiez ensuite la réponse de votre git adog dans reponse.md.\n\n\n\n\n\nPlacez-vous dans la branche fix-revert avec la commande suivante:\n$ git checkout fix-revert\nVous devriez voir apparaître le message suivant:\nSwitched to branch 'fix-revert' # ou l'équivalent en français :)\nVisualisez alors le log de votre dépôt grâce à la commande git adog. Dans le log, quelle information vous permet de vérifier que vous vous trouvez bien sur la branche fix-revert ?\nAnnulez les modifications apportées dans l’exercice 2 depuis la branche fix-revert avec la commande suivante:\n$ git revert HEAD\nÀ votre avis pourquoi avons-nous spécifié HEAD dans la commande git revert ?\n\n\n\n\n\n\n\nAttention\n\n\n\nAprès cette commande, Git vous demandera de saisir un message de commit dans l’éditeur de texte par défaut. Si vous avez configuré un éditeur, vous pouvez saisir votre message, enregistrer et quitter l’éditeur de texte et terminer la commande. Sinon Git va ouvrir vim par défaut. Vous devrez alors saisir votre message de commit dans vim. Pour ce faire, appuyez sur la touche i pour passer en mode insertion, saisissez votre message de commit, puis appuyez sur la touche ESC pour sortir du mode insertion. Enfin, saisissez :wq pour enregistrer votre message de commit et quitter l’éditeur de texte.\n\n\n\nVisualisez ensuite l’historique des commits avec la commande git log dans un premier temps. Vous devriez voir apparaître le commit que vous venez de créer.\nNous venons d’annulez les modifications apportées dans l’exercice 2. Cependant, nous souhaitons toujours que notre calculatrice gère l’opération de division. Corriger alors le problème de la division par 0 comme indiqué dans l’exercice 4. Testez ensuite le programme pour vérifier que tout fonctionne correctement.\nUne fois que c’est fait, ajoutez les fichiers modifiés à la zone d’index, puis créez un commit avec le message \"Fix divide function with git revert\".\nVisualisez l’historique des commits avec la commande git adog. Vous devriez voir apparaître le commit que vous venez de créer. Copiez ensuite la réponse de votre git adog dans reponse.md.\n\n\n\n\nNous sommes désormais en mesure d’intégrer la correction de la fonction divide dans la branche main. Nous allons utiliser la commande git merge. Bien que la correction ait été faite dans trois branches différentes, nous allons effectuer un unique merge puisque les corrections apportés sont exactement les mêmes.\n\n\n\n\n\n\nRemarque\n\n\n\nmerge fera l’objet d’un cours dédié. Nous verrons alors plus en détail son fonctionnement.\n\n\n\nReplacez-vous dans la branche principale en exécutant la commande suivante:\n$ git checkout main\nVérifiez que HEAD pointe bien sur la branche main avec la commande git adog. Vous devriez voir que les branches fix-checkout, fix-reset et fix-revert pointent toutes sur le commit tagué v1.0 et que HEAD pointe sur le commit Add divide function.\nExécutez la commande suivante pour intégrer les modifications de la branche fix-checkout dans la branche main:\n$ git merge fix-revert\n\n\n\n\n\n\n\nRemarque\n\n\n\nVous devriez avoir un message indiquant que le merge a été effectué en mode fast-forward. Nous verrons plus tard ce que cela signifie.\n\n\n\nTaguez enfin le dernier commit comme étant la version v2.0 de notre calculatrice et visualisez l’historique des commits avec la commande git log.\n\n\n\n\n\nNous avons désormais terminé ce TP. Effectuez un git status pour vérifier que tout est en ordre dans la branche principale. Assurez-vous d’avoir bien noté toutes vos réponses dans le fichier reponses.md. Et notez-y les commentaires que vous jugerez utiles sur les différentes commandes que nous avons utilisées dans ce TP.\nRetirez ensuite la ligne reponses.md du fichier .gitignore. Sauvegardez puis ajoutez les fichiers .gitignore et reponses.md dans la zone d’index.\nCréez enfin un commit avec le message \"Solution TP2\"."
  },
  {
    "objectID": "tp2.html#exercice-1---initialisation",
    "href": "tp2.html#exercice-1---initialisation",
    "title": "TP2 - Explorer l’historique des commits, annuler des modifications",
    "section": "",
    "text": "Dans le répertoire xcs310 créez un répertoire tp2 et initialisez-y un dépôt git vide. Lors de ce TP nous allons travailler avec le dépôt tp2. Pour ce faire nous allons écrire un petit programme python qui fera office d’une petite calulatrice basique.\nAssurez-vous que vous êtes bien à la racine du répertoire tp2 puis créez un fichier reponses.md dans lequel vous répondrez aux questions de ce TP. Créez également un fichier .gitignore et faîtes en sorte que Git ignore le fichier reponses.md pour le moment.\n\n\n\n\n\n\n\nIndication\n\n\n\nNotez au fur et à mesure vos réponses dans le fichier reponses.md. Vous pouvez également y noter les commandes que nous utiliserons dans ce TP.\n\n\n\nToujours dans le répertoire tp2, créez deux fichiers operation.py et calc.py qui contiendront respectivement les lignes de python ci-après.\n\n\noperation.py\n\ndef add(a, b):\n    return a + b\n\ndef subtract(a, b):\n    return a - b\n\ndef multiply(a, b):\n    return a * b\n\n\n\ncalc.py\n\nfrom operation import *\n\nif __name__ == \"__main__\":\n    while True:\n        input_str = input(\"Enter the calculation (in the format 'num1 operation num2', or 'exit' to exit): \")\n\n        if input_str == \"exit\":\n            break\n\n        num1, operation, num2 = input_str.split()\n        num1 = int(num1)\n        num2 = int(num2)\n\n        if operation == '+':\n            print(num1, \"+\", num2, \"=\", add(num1, num2))\n        elif operation == '-':\n            print(num1, \"-\", num2, \"=\", subtract(num1, num2))\n        elif operation == '*':\n            print(num1, \"*\", num2, \"=\", multiply(num1, num2))\n        else:\n            print(\"Invalid operation\")\n\nObservez le contenu des deux fichiers précédents. Vous devrez être en mesure de comprendre le fonctionnement de notre calculatrice. Exécutez le fichier calc.py pour vous assurer que tout fonctionne correctement.\nAjoutez une ligne dans le fichier .gitignore pour ignorer le répertoire __pycache__.\nAjoutez tous les nouveaux fichiers à la zone d’index, puis créez un commit avec le message \"Initial commit\".\nVisualisez l’historique des commits avec la commande git log. Vous devriez voir apparaître le commit que vous venez de créer. Copiez ensuite la réponse de votre git log dans reponse.md.\n\n\n\n\n\n\n\nWarning\n\n\n\nPensez à mettre un petit commentaire contenant le numéro de la question pour chaque réponse dans le fichier reponses.md.\n\n\n\nNous allons désormais taguer cette version de notre programme. Pour ce faire, créez un tag v1.0 sur le dernier commit avec la commande:\n$ git tag v1.0\nRegardez à nouveau l’historique des commits avec la commande git log. Vous devriez voir apparaître le tag que vous venez de créer. Copiez ensuite la réponse de votre git log dans reponse.md. Quelles différences remarquez vous entre ce log et celui de la question 7 ?"
  },
  {
    "objectID": "tp2.html#exercice-2---ajout-dune-fonction-de-division",
    "href": "tp2.html#exercice-2---ajout-dune-fonction-de-division",
    "title": "TP2 - Explorer l’historique des commits, annuler des modifications",
    "section": "",
    "text": "Nous allons désormais ajouter une nouvelle fonctionnalité à notre calculatrice. Pour ce faire, ajoutez les lignes de code suivantes à la fin du fichier operation.py:\n\n\noperation.py\n\ndef divide(a, b):\n    return a / b\n\nModifiez ensuite le fichier calc.py pour prendre en compte cette nouvelle fonctionnalité: ajoutez les lignes de code suivantes après la ligne 20 du fichier calc.py:\n\n\ncalc.py\n\nelif operation == '/':\n    print(num1, \"/\", num2, \"=\", divide(num1, num2))\n\nExécutez à nouveau le fichier calc.py pour vous assurer que tout fonctionne correctement. Une fois que c’est le cas, ajoutez tous les fichiers modifiés à la zone d’index, puis créez un commit avec le message \"Add divide function\".\nVisualisez l’historique des commits avec la commande git log. Vous devriez voir apparaître le commit que vous venez de créer. Copiez ensuite la réponse de votre git log dans reponse.md.\nComparez alors votre dernier log avec celui de la question 9 de l’exercice précédent. Que remarquez-vous ? Déduire le rôle de la référence HEAD dans Git ainsi que le rôle des tags."
  },
  {
    "objectID": "tp2.html#exercice-3---historique-condensé",
    "href": "tp2.html#exercice-3---historique-condensé",
    "title": "TP2 - Explorer l’historique des commits, annuler des modifications",
    "section": "",
    "text": "La commande git log permet d’afficher l’historique des commits. Cependant, il est possible de condenser cet historique en affichant uniquement les informations essentielles de chaque commit. Testez alors les commandes suivantes et observez leurs différences:\n$ git log --all\n$ git log --decorate\n$ git log --oneline\n$ git log --graph\nCopiez ensuite les réponses de ces log dans reponse.md.\nEssayez maintenant de combiner ces commandes pour afficher un historique condensé. Copiez ensuite la réponse de votre git log dans reponse.md. Puis testez enfin la commande suivante:\n$ git log --all --decorate --oneline --graph\nNotez également réponse de cette commande dans reponse.md.\nGit permet de créer ce que l’on appelle des alias. Ces alias permettent de créer des commandes personnalisées. Par exemple, nous pouvons créer un alias git adog qui affichera l’historique des commits de manière condensée (adog pour all, decorate, oneline, graph). Pour ce faire, exécutez la commande suivante:\n$ git config --global alias.adog \"log --all --decorate --oneline --graph\"\nTestez ensuite votre nouvel alias avec la commande git adog. Désormais, vous pouvez utiliser git adog à la place de git log --all --decorate --oneline --graph."
  },
  {
    "objectID": "tp2.html#exercice-4---oups-nous-avons-fait-une-erreur",
    "href": "tp2.html#exercice-4---oups-nous-avons-fait-une-erreur",
    "title": "TP2 - Explorer l’historique des commits, annuler des modifications",
    "section": "",
    "text": "Aïe! Nous venons de nous rendre compte que notre fonction divide ne fonctionne pas correctement. En effet, si on divise par 0, notre programme plante.\n\n\n\n\n\n\n\nAttention\n\n\n\nCes modifications ne sont pas encore à faire tout de suite! Nous allons d’abord créer des branches pour pouvoir travailler dessus.\n\n\nNous allons résoudre ce problème de la division par 0 en modifiant la fonction divide comme suit:\n\n\noperation.py\n\ndef divide(a, b):\n    try:\n        return a / b\n    except ZeroDivisionError:\n        print(\"Division by zero is not allowed\")\n        return None\n\net en modifiant le fichier calc.py comme suit à partir de la ligne 20:\n\n\ncalc.py\n\nelif operation == '/':\n    result = divide(num1, num2)\n    if result is not None:\n        print(num1, \"/\", num2, \"=\", result)\n\n\nNous allons effectuer la correction de notre programme de trois manières différentes: une avec la commande git checkout, une avec la commande git reset et une dernière avec la commande git revert. Pour ce faire, nous allons créer trois branches différentes. Créez alors une branche fix-checkout, une branche fix-reset et une branche fix-revert avec les commandes suivantes:\n$ git branch fix-checkout\n$ git branch fix-reset\n$ git branch fix-revert\nVisualisez l’historique de votre dépôt grâce à la commande git adog pour vérifier que les trois branches que nous avons créées sont bien présentes et se situent toutes sur le même commit. Copiez ensuite la réponse de votre git adog dans reponse.md."
  },
  {
    "objectID": "tp2.html#exercice-5---annuler-des-modifications-avec-git-checkout",
    "href": "tp2.html#exercice-5---annuler-des-modifications-avec-git-checkout",
    "title": "TP2 - Explorer l’historique des commits, annuler des modifications",
    "section": "",
    "text": "Placez-vous dans la branche fix-checkout avec la commande suivante:\n$ git checkout fix-checkout\nVous devriez voir apparaître le message suivant:\nSwitched to branch 'fix-checkout' # ou l'équivalent en français :)\nVisualisez alors le log de votre dépôt grâce à la commande git adog. Dans la réponse de la commande, quelle information vous permet de vérifier que vous vous trouvez bien sur la branche fix-checkout ?\nLa dernière version stable de notre programme est la version taguée v1.0. Nous voudrions alors que les fichiers calc.py et operation.py retrouvent leur état de la version v1.0. Exécutez alors la commande suivante:\n$ git checkout v1.0 calc.py operation.py\nOuvrez ensuite les fichiers calc.py et operation.py et vérifiez que les modifications que vous avez apportées dans l’exercice 2 ont bien été annulées, c’est-à-dire que notre calculatrice ne gère plus l’opération de division.\nModifiez ensuite les fichiers calc.py et operation.py pour corriger le problème de la division par 0 comme indiqué dans l’exercice 4. Testez ensuite le programme pour vérifier que tout fonctionne correctement.\nUne fois que c’est fait, ajoutez les fichiers modifiés à la zone d’index, puis créez un commit avec le message \"Fix divide function with git checkout\".\nVisualisez l’historique des commits avec la commande git adog. Vous devriez voir apparaître le commit que vous venez de créer. Copiez ensuite la réponse de votre git adog dans reponse.md."
  },
  {
    "objectID": "tp2.html#exercice-6---annuler-des-modifications-avec-git-reset",
    "href": "tp2.html#exercice-6---annuler-des-modifications-avec-git-reset",
    "title": "TP2 - Explorer l’historique des commits, annuler des modifications",
    "section": "",
    "text": "Placez-vous dans la branche fix-reset avec la commande suivante:\n$ git checkout fix-reset\nVous devriez voir apparaître le message suivant:\nSwitched to branch 'fix-reset' # ou l'équivalent en français :)\nVisualisez alors le log de votre dépôt grâce à la commande git log. Dans le log, quelle information vous permet de vérifier que vous vous trouvez bien sur la branche fix-reset ?\nEffectuez un git status pour vérifier l’état de notre dépôt. Y-a-t-il des fichiers modifiés ? Y-a-t’il des modifications en attente de validation ?\nOn souhaite maintenant annuler les modifications apportées dans l’exercice 2. Pour ce faire, exécutez la commande suivante:\n$ git reset --hard HEAD~1\nCette commande permet de revenir au commit précédent en annulant toutes les modifications apportées depuis le dernier commit.\nObservez que les modifications apportées dans l’exercice 2 ont bien été annulées. C’est-à-dire que notre calculatrice ne gère plus l’opération de division et que nous sommes retournés à la version taguée v1.0. Vérifiez ceci en effectuant un git log et que le HEAD et la branche fix-reset pointent bien tous les deux sur le commit tagué v1.0.\nCorriger ensuite le problème de la division par 0 comme indiqué dans l’exercice 4. Testez ensuite le programme pour vérifier que tout fonctionne correctement.\nUne fois que c’est fait, ajoutez les fichiers modifiés à la zone d’index, puis créez un commit avec le message \"Fix divide function with git reset\".\nVisualisez l’historique des commits avec la commande git adog. Vous devriez voir apparaître le commit que vous venez de créer. Copiez ensuite la réponse de votre git adog dans reponse.md."
  },
  {
    "objectID": "tp2.html#exercice-7---annuler-des-modifications-avec-git-revert",
    "href": "tp2.html#exercice-7---annuler-des-modifications-avec-git-revert",
    "title": "TP2 - Explorer l’historique des commits, annuler des modifications",
    "section": "",
    "text": "Placez-vous dans la branche fix-revert avec la commande suivante:\n$ git checkout fix-revert\nVous devriez voir apparaître le message suivant:\nSwitched to branch 'fix-revert' # ou l'équivalent en français :)\nVisualisez alors le log de votre dépôt grâce à la commande git adog. Dans le log, quelle information vous permet de vérifier que vous vous trouvez bien sur la branche fix-revert ?\nAnnulez les modifications apportées dans l’exercice 2 depuis la branche fix-revert avec la commande suivante:\n$ git revert HEAD\nÀ votre avis pourquoi avons-nous spécifié HEAD dans la commande git revert ?\n\n\n\n\n\n\n\nAttention\n\n\n\nAprès cette commande, Git vous demandera de saisir un message de commit dans l’éditeur de texte par défaut. Si vous avez configuré un éditeur, vous pouvez saisir votre message, enregistrer et quitter l’éditeur de texte et terminer la commande. Sinon Git va ouvrir vim par défaut. Vous devrez alors saisir votre message de commit dans vim. Pour ce faire, appuyez sur la touche i pour passer en mode insertion, saisissez votre message de commit, puis appuyez sur la touche ESC pour sortir du mode insertion. Enfin, saisissez :wq pour enregistrer votre message de commit et quitter l’éditeur de texte.\n\n\n\nVisualisez ensuite l’historique des commits avec la commande git log dans un premier temps. Vous devriez voir apparaître le commit que vous venez de créer.\nNous venons d’annulez les modifications apportées dans l’exercice 2. Cependant, nous souhaitons toujours que notre calculatrice gère l’opération de division. Corriger alors le problème de la division par 0 comme indiqué dans l’exercice 4. Testez ensuite le programme pour vérifier que tout fonctionne correctement.\nUne fois que c’est fait, ajoutez les fichiers modifiés à la zone d’index, puis créez un commit avec le message \"Fix divide function with git revert\".\nVisualisez l’historique des commits avec la commande git adog. Vous devriez voir apparaître le commit que vous venez de créer. Copiez ensuite la réponse de votre git adog dans reponse.md."
  },
  {
    "objectID": "tp2.html#exercice-8---intégration-des-modifications",
    "href": "tp2.html#exercice-8---intégration-des-modifications",
    "title": "TP2 - Explorer l’historique des commits, annuler des modifications",
    "section": "",
    "text": "Nous sommes désormais en mesure d’intégrer la correction de la fonction divide dans la branche main. Nous allons utiliser la commande git merge. Bien que la correction ait été faite dans trois branches différentes, nous allons effectuer un unique merge puisque les corrections apportés sont exactement les mêmes.\n\n\n\n\n\n\nRemarque\n\n\n\nmerge fera l’objet d’un cours dédié. Nous verrons alors plus en détail son fonctionnement.\n\n\n\nReplacez-vous dans la branche principale en exécutant la commande suivante:\n$ git checkout main\nVérifiez que HEAD pointe bien sur la branche main avec la commande git adog. Vous devriez voir que les branches fix-checkout, fix-reset et fix-revert pointent toutes sur le commit tagué v1.0 et que HEAD pointe sur le commit Add divide function.\nExécutez la commande suivante pour intégrer les modifications de la branche fix-checkout dans la branche main:\n$ git merge fix-revert\n\n\n\n\n\n\n\nRemarque\n\n\n\nVous devriez avoir un message indiquant que le merge a été effectué en mode fast-forward. Nous verrons plus tard ce que cela signifie.\n\n\n\nTaguez enfin le dernier commit comme étant la version v2.0 de notre calculatrice et visualisez l’historique des commits avec la commande git log."
  },
  {
    "objectID": "tp2.html#exercice-9---bilan-et-complétion-du-fichier-reponses.md",
    "href": "tp2.html#exercice-9---bilan-et-complétion-du-fichier-reponses.md",
    "title": "TP2 - Explorer l’historique des commits, annuler des modifications",
    "section": "",
    "text": "Nous avons désormais terminé ce TP. Effectuez un git status pour vérifier que tout est en ordre dans la branche principale. Assurez-vous d’avoir bien noté toutes vos réponses dans le fichier reponses.md. Et notez-y les commentaires que vous jugerez utiles sur les différentes commandes que nous avons utilisées dans ce TP.\nRetirez ensuite la ligne reponses.md du fichier .gitignore. Sauvegardez puis ajoutez les fichiers .gitignore et reponses.md dans la zone d’index.\nCréez enfin un commit avec le message \"Solution TP2\"."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Syllabus",
    "section": "",
    "text": "Comprendre les concepts de bases de la gestion de version d’un projet informatique\nÊtre capable d’utiliser Git dans le cadre de travaux collaboratifs\nBonnes pratiques, résolution de problèmes, utilisation quotidienne"
  },
  {
    "objectID": "index.html#commandes-de-base-de-gestion-de-dépôt",
    "href": "index.html#commandes-de-base-de-gestion-de-dépôt",
    "title": "Syllabus",
    "section": "Commandes de base de gestion de dépôt",
    "text": "Commandes de base de gestion de dépôt\n\nEnseigner les commandes de base du système de gestion de dépôt, telles que la création d’un nouveau dépôt, l’ajout de fichiers, la création de branches, la fusion des branches, etc.\nPrésenter les commandes pour suivre l’historique des modifications et effectuer des opérations de base, comme la création de tags et la révision des modifications"
  },
  {
    "objectID": "index.html#gestion-des-branches-et-des-fusions",
    "href": "index.html#gestion-des-branches-et-des-fusions",
    "title": "Syllabus",
    "section": "Gestion des branches et des fusions",
    "text": "Gestion des branches et des fusions\n\nExpliquer l’importance de la gestion des branches dans les projets de développement\nEnseigner les techniques de création, de modification et de fusion de branches\nExpliquer les stratégies de fusion et les bonnes pratiques associées"
  },
  {
    "objectID": "index.html#collaboration-et-gestion-de-conflits",
    "href": "index.html#collaboration-et-gestion-de-conflits",
    "title": "Syllabus",
    "section": "Collaboration et gestion de conflits",
    "text": "Collaboration et gestion de conflits\n\nPrésenter les concepts de collaboration dans un environnement de gestion de dépôt\nExpliquer les problèmes de conflits qui peuvent survenir lors de la fusion de modifications concurrentes\nEnseigner les techniques pour résoudre les conflits et assurer une collaboration efficace"
  },
  {
    "objectID": "index.html#utilisation-de-github",
    "href": "index.html#utilisation-de-github",
    "title": "Syllabus",
    "section": "Utilisation de Github",
    "text": "Utilisation de Github\n\nCréation d’un dépôt sur Github\nCollaborer sur un projet Github\nIssues et Pull request"
  },
  {
    "objectID": "index.html#projet",
    "href": "index.html#projet",
    "title": "Syllabus",
    "section": "Projet",
    "text": "Projet\n\nPrésenter les bonnes pratiques en matière de gestion de dépôt, telles que l’utilisation de messages de commit clairs, la création de commits atomiques, la documentation du code, etc.\nExpliquer comment maintenir un historique de version propre et organisé\nEntraînement à l’utilisation de GIT dans le contexte d’un projet à plusieurs personnes."
  },
  {
    "objectID": "tp3.html",
    "href": "tp3.html",
    "title": "TP3 - Branches et Fusion",
    "section": "",
    "text": "Objectif\n\n\n\nS’exercer à créer des branches et naviguer entre elles.\n\n\n\n\n\nCréez un nouveau dépôt Git :\n\nmkdir tp3\ncd tp3\ngit init\n\nCréez un fichier README.md avec le contenu suivant :\n\n# Projet d'exercice\nVersion initiale du projet\n\nFaites votre premier commit :\n\ngit add README.md\ngit commit -m \"Premier commit : création du README\"\n\n\n\nRéalisez les tâches suivantes :\n\nCréez une branche nommée feature-1\nCréez une branche nommée feature-2\nAffichez la liste des branches\nDéplacez-vous sur feature-1\nModifiez le README pour ajouter une ligne “Modification dans feature-1”\nCommittez ce changement\nRetournez sur la branche main\nVérifiez que le README n’a pas la modification\n\n\n\n\n\n\n\nQuestions bonus\n\n\n\n\nQue se passe-t-il si vous essayez de supprimer une branche sur laquelle vous êtes ?\nComment voir les différences entre les branches main et feature-1 ?"
  },
  {
    "objectID": "tp3.html#exercice-1-création-et-navigation-entre-branches",
    "href": "tp3.html#exercice-1-création-et-navigation-entre-branches",
    "title": "TP3 - Branches et Fusion",
    "section": "",
    "text": "Objectif\n\n\n\nS’exercer à créer des branches et naviguer entre elles.\n\n\n\n\n\nCréez un nouveau dépôt Git :\n\nmkdir tp3\ncd tp3\ngit init\n\nCréez un fichier README.md avec le contenu suivant :\n\n# Projet d'exercice\nVersion initiale du projet\n\nFaites votre premier commit :\n\ngit add README.md\ngit commit -m \"Premier commit : création du README\"\n\n\n\nRéalisez les tâches suivantes :\n\nCréez une branche nommée feature-1\nCréez une branche nommée feature-2\nAffichez la liste des branches\nDéplacez-vous sur feature-1\nModifiez le README pour ajouter une ligne “Modification dans feature-1”\nCommittez ce changement\nRetournez sur la branche main\nVérifiez que le README n’a pas la modification\n\n\n\n\n\n\n\nQuestions bonus\n\n\n\n\nQue se passe-t-il si vous essayez de supprimer une branche sur laquelle vous êtes ?\nComment voir les différences entre les branches main et feature-1 ?"
  },
  {
    "objectID": "tp3.html#exercice-2-fusion-simple",
    "href": "tp3.html#exercice-2-fusion-simple",
    "title": "TP3 - Branches et Fusion",
    "section": "2 Exercice 2 : Fusion simple",
    "text": "2 Exercice 2 : Fusion simple\n\n\n\n\n\n\nObjectif\n\n\n\nPratiquer la fusion de branches sans conflits.\n\n\n\n2.1 Instructions\n\nPartez de la branche main\nRéalisez les actions suivantes :\n\nCréez une branche dev\nDans dev, créez un fichier notes.txt avec du contenu\nCommittez ce fichier\nRetournez sur main\nFusionnez dev dans main\nVérifiez que le fichier notes.txt est bien présent\nSupprimez la branche dev"
  },
  {
    "objectID": "tp3.html#exercice-3-gestion-des-conflits",
    "href": "tp3.html#exercice-3-gestion-des-conflits",
    "title": "TP3 - Branches et Fusion",
    "section": "3 Exercice 3 : Gestion des conflits",
    "text": "3 Exercice 3 : Gestion des conflits\n\n\n\n\n\n\nObjectif\n\n\n\nApprendre à gérer les conflits de fusion.\n\n\n\n3.1 Instructions\n\nCréez une nouvelle branche conflit-test\nSur la branche main, modifiez la première ligne du README :\n\n# Projet d'exercice - Version Main\n\nCommittez ce changement\nBasculez sur conflit-test\nModifiez la même ligne du README différemment :\n\n# Projet d'exercice - Version Test\n\nCommittez ce changement\nRetournez sur main\nEssayez de fusionner conflit-test dans main\nRésolvez le conflit en gardant les deux informations :\n\n# Projet d'exercice - Version Main et Test"
  },
  {
    "objectID": "tp3.html#exercice-4-rebase",
    "href": "tp3.html#exercice-4-rebase",
    "title": "TP3 - Branches et Fusion",
    "section": "4 Exercice 4 : Rebase",
    "text": "4 Exercice 4 : Rebase\n\n\n\n\n\n\nObjectif\n\n\n\nComprendre et pratiquer le rebase.\n\n\n\n4.1 Instructions\n\nCréez une branche feature-rebase\nDans cette branche :\n\nAjoutez un fichier feature.txt\nFaites plusieurs commits\n\nPendant ce temps, dans main :\n\nFaites des modifications différentes\nCréez quelques commits\n\nDans feature-rebase :\n\nFaites un rebase sur main\nObservez l’historique des commits"
  },
  {
    "objectID": "tp3.html#exercice-5-branches-et-historique",
    "href": "tp3.html#exercice-5-branches-et-historique",
    "title": "TP3 - Branches et Fusion",
    "section": "5 Exercice 5 : Branches et historique",
    "text": "5 Exercice 5 : Branches et historique\n\n\n\n\n\n\nObjectif\n\n\n\nPratiquer la visualisation et la compréhension de l’historique Git.\n\n\n\n5.1 Instructions\n\nCréez plusieurs branches :\n\ngit branch feature-a\ngit branch feature-b\ngit branch feature-c\n\nDans chaque branche :\n\nFaites au moins deux commits\nUtilisez des fichiers différents pour éviter les conflits\n\nFusionnez toutes les branches dans main\nPratiquez les commandes de visualisation :\n\ngit log --all --decorate --oneline --graph\n# ou 'git adog' si vous avez configuré l'alias dans le TP1\ngit branch -v\ngit branch --merged\ngit branch --no-merged"
  },
  {
    "objectID": "tp3.html#notes-pratiques",
    "href": "tp3.html#notes-pratiques",
    "title": "TP3 - Branches et Fusion",
    "section": "6 Notes pratiques",
    "text": "6 Notes pratiques\n\n\n\n\n\n\nCommandes utiles pour tous les exercices\n\n\n\n\nUtilisez régulièrement git status pour voir l’état de votre dépôt\nUtilisez git log --all --decorate --oneline --graph ou l’alias git adog pour visualiser l’historique\nN’hésitez pas à utiliser git branch -v pour voir les derniers commits de chaque branche\nSi vous vous trompez, vous pouvez toujours utiliser git reset --hard pour revenir à un état précédent"
  },
  {
    "objectID": "tp3.html#solutions-communes-aux-problèmes",
    "href": "tp3.html#solutions-communes-aux-problèmes",
    "title": "TP3 - Branches et Fusion",
    "section": "7 Solutions communes aux problèmes",
    "text": "7 Solutions communes aux problèmes\n\n\n\n\n\n\nEn cas de problème\n\n\n\n\nSi vous ne pouvez pas supprimer une branche :\n\ngit branch -D nom-branche  # Force la suppression\n\nPour annuler une fusion en cours :\n\ngit merge --abort\n\nPour annuler un rebase en cours :\n\ngit rebase --abort\n\nPour voir les différences entre deux branches :\n\ngit diff branche1..branche2\n\nPour voir quelles branches ont été fusionnées :\n\ngit branch --merged"
  },
  {
    "objectID": "tp3.html#learn-git-branching",
    "href": "tp3.html#learn-git-branching",
    "title": "TP3 - Branches et Fusion",
    "section": "8 Learn Git Branching",
    "text": "8 Learn Git Branching\nDémarrez l’outil “Learn Git Branching” sur l’espace Moodle.\n\nChoisissez la langue en bas à droite\nExercices à faire:\n\nIntroduction Sequence\nRamping up\nMoving Work Around\n\nLes autres exercices sont optionnels\nVotre score apparaît en haut à gauche et sera enregistré dans Moodle"
  },
  {
    "objectID": "tp1.html",
    "href": "tp1.html",
    "title": "TP1 - Premiers pas avec Git",
    "section": "",
    "text": "Pour installer Git sur votre machine, rendez-vous sur le site officiel de Git et téléchargez la dernière version de Git pour votre système d’exploitation. Suivez les instructions d’installation pour installer Git sur votre machine. Le lien vers le site officiel de Git est le suivant : https://git-scm.com/downloads.\n\n\n\n\n\n\nGit en ligne de commande\n\n\n\n\nDans toute la suite de ce TP, nous allons utiliser Git en ligne de commande. Pour ce faire, vous devez ouvrir un terminal sur votre machine. Si vous êtes sur Windows, vous pouvez utiliser Git Bash pour exécuter les commandes Git. Si vous êtes sur Linux ou Mac, vous pouvez utiliser le terminal intégré à votre système d’exploitation.\nDevant chaque commande, vous verrez le symbole $. Ce symbole représente le prompt de votre terminal. Vous ne devez pas le copier lorsque vous exécutez les commandes Git.\nLes lignes de commandes précédées du symbole # sont des commentaires. Vous ne devez pas les copier lorsque vous exécutez les commandes.\n\n\n\n\n\n\n\n\nOuvrez un terminal (Git Bash pour Windows) et exécutez la commande suivante pour vérifier que Git est installé sur votre machine :\n$ git --version\nVous devriez voir la version de Git installée sur votre machine.\nMaintenant, vous devez configurer votre identité Git. Pour ce faire, exécutez les commandes ci-apèrs en remplaçant les valeurs par vos propres informations. Par exemple si votre nom est John Doe et que votre adresse e-mail est john.doe@email.com, vous devez executer :\n$ git config --global user.name \"John Doe\"\n$ git config --global user.email \"john.doe@email.com\"\nConfigurez ensuite les fin de ligne. Pour ce faire, exécutez la commande suivante : bash     $ git config --global core.autocrlf input Avec cette configuration, les fichiers édités sous windows (fin de ligne = CRLF) seront convertis au format Unix (fin de ligne = LF) lors des commits. Cela permet de partager des fichiers facilement entre Windows et Unix. Voir https://stackoverflow.com/a/1112313\nPar défaut, l’éditeur de texte utilisé par Git est vim. Si vous n’avez pas d’éditeur de texte préféré, vous pouvez utiliser vim. Par exemple, si vous utilisez Visual Studio Code, vous pouvez exécuter la commande suivante :\n$ git config --global core.editor \"code --wait\"\nNous allons ensuite faire en sorte que le nom de la branche principale de notre dépôt soit main au lieu de master. Pour ce faire, exécutez la commande suivante :\n$ git config --global init.defaultBranch main\nPour vérifier que la configuration a été appliquée, exécutez la commande suivante :\n$ git config --list\nVous devriez voir la liste des configurations appliquées.\n\n\n\n\n\n\n\n\nDans un premier temps nous allons créer un repertoire xcs310 dans votre répertoire personnel. Nous allons utiliser ce répertoire pour travailler sur tous les tp de ce cours. Pour ce faire, exécutez la commande suivante :\n# Commande à exécuter dans votre répertoire personnel\n$ mkdir xcs310\nDéplacez-vous ensuite dans le répertoire xcs310 et créer y un nouveau repertoire tp1. Enfin déplacez vous dans le répertoire tp1. Pour ce faire, exécutez les commandes suivantes :\n$ cd xcs310\n$ mkdir tp1\n$ cd tp1\nInitialisez ensuite un dépôt Git dans le répertoire tp1 en exécutant la commande suivante :\n$ git init\nQuels sont les résultats de la commande ? Que peut-on voir dans le répertoire tp1 ?\n\n\n\n\n\n\n\nTip\n\n\n\nPour voir les fichiers cachés dans le répertoire tp1, vous pouvez exécuter la commande suivante :\n$ ls -a\n\n\n\nLa commande git status permet de voir l’état du dépôt Git. Exécutez la commande suivante :\n$ git status\nDans quel état se trouve votre dépôt Git ?\n\n\n\n\n\nCréez un fichier hello.py dans le répertoire tp1 et ajoutez-y le code suivant :\nprint(\"Hello World!\")\nUne fois ce fichier créé, vérifiez l’état de votre dépôt Git en exécutant la commande git status. Quelles sont les différences par rapport à l’état précédent ?\nAjoutez le fichier hello.py à l’index Git en exécutant la commande suivante :\n$ git add hello.py\nVérifiez l’état de votre dépôt Git en exécutant la commande git status. Quelles sont les différences par rapport à l’état précédent ?\nCréez un commit pour valider les changements apportés au dépôt Git. Pour ce faire, exécutez la commande suivante :\n$ git commit -m \"Premier commit\"\nVérifiez l’état de votre dépôt Git en exécutant la commande git status. Quelles sont les différences par rapport à l’état précédent ?\nNous avons désormais un commit dans l’historique de notre dépôt Git. Pour voir l’historique des commits, exécutez la commande suivante :\n$ git log\nQuelles sont les informations affichées par la commande ?\n\n\n\n\n\n\nToujours dans le répertoire tp1, créez un fichier README.md et ajoutez-y le contenu suivant :\n# TP1 - Premiers pas avec Git\nEnregistrez ensuite le fichier README.md.\n\nDans quelle zone de travail se situe les modifications apportées au fichier README.md ?\nTentez de directement créer un commit pour valider les modifications apportées au fichier README.md avec le message \"Ajout du fichier README.md\". Quel est le résultat de la commande ? Pourquoi ?\nQuelle commande permet de déplacer les modifications apportées au fichier README.md dans la zone d’index ? Exécutez cette commande.\nDéplacez ensuite les modifications apportées au fichier README.md depuis l’index vers le dépôt Git avec la commande git commit. Utilisez le message \"Ajout du fichier README.md\".\nListez ensuite l’historique des commits.\nTirer une conclusion quant au passage des modifications d’une zone de travail à une autre.\n\n\n\n\n\nNous allons désormais ajouter quelques fichiers python en plus dans notre dépôt et réorganiser les fichiers dans des répertoires. À la racine du répertoire tp1, créez un répertoire src et déplacez-y le fichier hello.py (utilisez un couper/coller).\n\nFaites un git status pour voir l’état de votre dépôt Git. Que remarquez-vous pour le fichier hello.py ?\nSupprimez le fichier hello.py du dépôt Git avec la commande suivante :\n$ git rm --cached hello.py\nFaites un git status pour voir l’état de votre dépôt Git. Que remarquez-vous pour le fichier hello.py ?\n\n\n\n\n\n\n\nNote\n\n\n\nLa commande git rm --cached permet de supprimer un fichier du dépôt Git sans le supprimer dans le répertoire de travail. Le fichier hello.py est donc toujours présent dans le répertoire src mais il n’est plus suivi par Git.\n\n\n\nModifier le contenu du fichier src/hello.py pour qu’il affiche de telle sorte que le print(\"Hello World\") soit contenue dans une fonction hello_world(). Le fichier hello.py doit donc contenir le code suivant :\ndef hello_world():\n    print(\"Hello World!\")\nEnregistrez ensuite le fichier hello.py.\nToujours dans le répertoire src, créez un fichier main.py et ajoutez-y le code suivant :\nfrom hello import hello_world\n\nif __name__ == \"__main__\":\n    hello_world()\nEnregistrez ensuite le fichier main.py.\nExécutez le fichier main.py pour vérifier que le code fonctionne correctement.\nExécutez ensuite la commande git status. Que remarquez-vous ?\nAjoutez les fichiers hello.py et main.py à la zone d’index Git en exécutant la commande suivante (commande à exécuter dans le répertoire src):\n# Pour ce déplacer dans le répertoire src\n$ cd src\n# Pour ajouter les fichiers de src dans la zone d'index\n$ git add *.py\n\n\n\n\n\n\n\nNote\n\n\n\nLa commande git add *.py permet d’ajouter tous les fichiers dont l’extention est .py du répertoire courant à l’index Git.\n\n\n\nValidez ensuite les changements apportés au dépôt Git en créant un commit avec le message \"Ajout des fichiers hello.py et main.py\".\n\n\n\n\n\nVous l’avez surement remarquez, après avoir exécuté le script main.py, un répértoire __pycache__ a été créé dans le répertoire src. Ce répertoire contient des fichiers générés par Python. Nous allons demander à Git de ne pas le suivre.\n\nDéplacez-vous à la racine du répertoire tp1. Vérifier le statut de votre dépôt Git pour voir si le répertoire __pycache__ est toujours mentionné comme étant non suivi par Git.\nCréez un fichier .gitignore à la racine du répertoire tp1 et ajoutez la ligne suivante dans le fichier .gitignore :\n__pycache__\nEnregistrez ensuite le fichier .gitignore.\n\n\n\n\n\n\n\nNote\n\n\n\nLe . devant le nom du fichier .gitignore indique que le fichier est caché, exactement de la même manière que le répertoire .git à la racine de notre dépôt est caché.\n\n\n\nAjoutez ensuite le fichier .gitignore à l’index Git et créez un commit pour valider les changements apportés au dépôt Git. Utilisez le message \"Ajout du fichier .gitignore\".\nVérifiez ensuite le statut de votre dépôt Git pour voir si le répertoire __pycache__ est toujours mentionné comme étant non suivi par Git.\n\n\n\n\n\nOuvrez le fichier README.md puis :\n\nNotez dedans les réponses aux questions posées dans les exercices précédents de ce TP.\nListez également les commandes Git que vous avez utilisées dans ce TP et expliquez à quoi elles servent.\nAjoutez ensuite le fichier README.md à l’index Git et créez un commit pour valider les changements apportés au fichier README.md. Utilisez le message \"solution TP1\"."
  },
  {
    "objectID": "tp1.html#installer-git-sur-votre-machine",
    "href": "tp1.html#installer-git-sur-votre-machine",
    "title": "TP1 - Premiers pas avec Git",
    "section": "",
    "text": "Pour installer Git sur votre machine, rendez-vous sur le site officiel de Git et téléchargez la dernière version de Git pour votre système d’exploitation. Suivez les instructions d’installation pour installer Git sur votre machine. Le lien vers le site officiel de Git est le suivant : https://git-scm.com/downloads.\n\n\n\n\n\n\nGit en ligne de commande\n\n\n\n\nDans toute la suite de ce TP, nous allons utiliser Git en ligne de commande. Pour ce faire, vous devez ouvrir un terminal sur votre machine. Si vous êtes sur Windows, vous pouvez utiliser Git Bash pour exécuter les commandes Git. Si vous êtes sur Linux ou Mac, vous pouvez utiliser le terminal intégré à votre système d’exploitation.\nDevant chaque commande, vous verrez le symbole $. Ce symbole représente le prompt de votre terminal. Vous ne devez pas le copier lorsque vous exécutez les commandes Git.\nLes lignes de commandes précédées du symbole # sont des commentaires. Vous ne devez pas les copier lorsque vous exécutez les commandes."
  },
  {
    "objectID": "tp1.html#configurer-git",
    "href": "tp1.html#configurer-git",
    "title": "TP1 - Premiers pas avec Git",
    "section": "",
    "text": "Ouvrez un terminal (Git Bash pour Windows) et exécutez la commande suivante pour vérifier que Git est installé sur votre machine :\n$ git --version\nVous devriez voir la version de Git installée sur votre machine.\nMaintenant, vous devez configurer votre identité Git. Pour ce faire, exécutez les commandes ci-apèrs en remplaçant les valeurs par vos propres informations. Par exemple si votre nom est John Doe et que votre adresse e-mail est john.doe@email.com, vous devez executer :\n$ git config --global user.name \"John Doe\"\n$ git config --global user.email \"john.doe@email.com\"\nConfigurez ensuite les fin de ligne. Pour ce faire, exécutez la commande suivante : bash     $ git config --global core.autocrlf input Avec cette configuration, les fichiers édités sous windows (fin de ligne = CRLF) seront convertis au format Unix (fin de ligne = LF) lors des commits. Cela permet de partager des fichiers facilement entre Windows et Unix. Voir https://stackoverflow.com/a/1112313\nPar défaut, l’éditeur de texte utilisé par Git est vim. Si vous n’avez pas d’éditeur de texte préféré, vous pouvez utiliser vim. Par exemple, si vous utilisez Visual Studio Code, vous pouvez exécuter la commande suivante :\n$ git config --global core.editor \"code --wait\"\nNous allons ensuite faire en sorte que le nom de la branche principale de notre dépôt soit main au lieu de master. Pour ce faire, exécutez la commande suivante :\n$ git config --global init.defaultBranch main\nPour vérifier que la configuration a été appliquée, exécutez la commande suivante :\n$ git config --list\nVous devriez voir la liste des configurations appliquées."
  },
  {
    "objectID": "tp1.html#premier-dépôt-git",
    "href": "tp1.html#premier-dépôt-git",
    "title": "TP1 - Premiers pas avec Git",
    "section": "",
    "text": "Dans un premier temps nous allons créer un repertoire xcs310 dans votre répertoire personnel. Nous allons utiliser ce répertoire pour travailler sur tous les tp de ce cours. Pour ce faire, exécutez la commande suivante :\n# Commande à exécuter dans votre répertoire personnel\n$ mkdir xcs310\nDéplacez-vous ensuite dans le répertoire xcs310 et créer y un nouveau repertoire tp1. Enfin déplacez vous dans le répertoire tp1. Pour ce faire, exécutez les commandes suivantes :\n$ cd xcs310\n$ mkdir tp1\n$ cd tp1\nInitialisez ensuite un dépôt Git dans le répertoire tp1 en exécutant la commande suivante :\n$ git init\nQuels sont les résultats de la commande ? Que peut-on voir dans le répertoire tp1 ?\n\n\n\n\n\n\n\nTip\n\n\n\nPour voir les fichiers cachés dans le répertoire tp1, vous pouvez exécuter la commande suivante :\n$ ls -a\n\n\n\nLa commande git status permet de voir l’état du dépôt Git. Exécutez la commande suivante :\n$ git status\nDans quel état se trouve votre dépôt Git ?\n\n\n\n\n\nCréez un fichier hello.py dans le répertoire tp1 et ajoutez-y le code suivant :\nprint(\"Hello World!\")\nUne fois ce fichier créé, vérifiez l’état de votre dépôt Git en exécutant la commande git status. Quelles sont les différences par rapport à l’état précédent ?\nAjoutez le fichier hello.py à l’index Git en exécutant la commande suivante :\n$ git add hello.py\nVérifiez l’état de votre dépôt Git en exécutant la commande git status. Quelles sont les différences par rapport à l’état précédent ?\nCréez un commit pour valider les changements apportés au dépôt Git. Pour ce faire, exécutez la commande suivante :\n$ git commit -m \"Premier commit\"\nVérifiez l’état de votre dépôt Git en exécutant la commande git status. Quelles sont les différences par rapport à l’état précédent ?\nNous avons désormais un commit dans l’historique de notre dépôt Git. Pour voir l’historique des commits, exécutez la commande suivante :\n$ git log\nQuelles sont les informations affichées par la commande ?"
  },
  {
    "objectID": "tp1.html#déplacer-des-modifications-dans-les-différentes-zones-de-travail",
    "href": "tp1.html#déplacer-des-modifications-dans-les-différentes-zones-de-travail",
    "title": "TP1 - Premiers pas avec Git",
    "section": "",
    "text": "Toujours dans le répertoire tp1, créez un fichier README.md et ajoutez-y le contenu suivant :\n# TP1 - Premiers pas avec Git\nEnregistrez ensuite le fichier README.md.\n\nDans quelle zone de travail se situe les modifications apportées au fichier README.md ?\nTentez de directement créer un commit pour valider les modifications apportées au fichier README.md avec le message \"Ajout du fichier README.md\". Quel est le résultat de la commande ? Pourquoi ?\nQuelle commande permet de déplacer les modifications apportées au fichier README.md dans la zone d’index ? Exécutez cette commande.\nDéplacez ensuite les modifications apportées au fichier README.md depuis l’index vers le dépôt Git avec la commande git commit. Utilisez le message \"Ajout du fichier README.md\".\nListez ensuite l’historique des commits.\nTirer une conclusion quant au passage des modifications d’une zone de travail à une autre."
  },
  {
    "objectID": "tp1.html#modifications-de-fichiers",
    "href": "tp1.html#modifications-de-fichiers",
    "title": "TP1 - Premiers pas avec Git",
    "section": "",
    "text": "Nous allons désormais ajouter quelques fichiers python en plus dans notre dépôt et réorganiser les fichiers dans des répertoires. À la racine du répertoire tp1, créez un répertoire src et déplacez-y le fichier hello.py (utilisez un couper/coller).\n\nFaites un git status pour voir l’état de votre dépôt Git. Que remarquez-vous pour le fichier hello.py ?\nSupprimez le fichier hello.py du dépôt Git avec la commande suivante :\n$ git rm --cached hello.py\nFaites un git status pour voir l’état de votre dépôt Git. Que remarquez-vous pour le fichier hello.py ?\n\n\n\n\n\n\n\nNote\n\n\n\nLa commande git rm --cached permet de supprimer un fichier du dépôt Git sans le supprimer dans le répertoire de travail. Le fichier hello.py est donc toujours présent dans le répertoire src mais il n’est plus suivi par Git.\n\n\n\nModifier le contenu du fichier src/hello.py pour qu’il affiche de telle sorte que le print(\"Hello World\") soit contenue dans une fonction hello_world(). Le fichier hello.py doit donc contenir le code suivant :\ndef hello_world():\n    print(\"Hello World!\")\nEnregistrez ensuite le fichier hello.py.\nToujours dans le répertoire src, créez un fichier main.py et ajoutez-y le code suivant :\nfrom hello import hello_world\n\nif __name__ == \"__main__\":\n    hello_world()\nEnregistrez ensuite le fichier main.py.\nExécutez le fichier main.py pour vérifier que le code fonctionne correctement.\nExécutez ensuite la commande git status. Que remarquez-vous ?\nAjoutez les fichiers hello.py et main.py à la zone d’index Git en exécutant la commande suivante (commande à exécuter dans le répertoire src):\n# Pour ce déplacer dans le répertoire src\n$ cd src\n# Pour ajouter les fichiers de src dans la zone d'index\n$ git add *.py\n\n\n\n\n\n\n\nNote\n\n\n\nLa commande git add *.py permet d’ajouter tous les fichiers dont l’extention est .py du répertoire courant à l’index Git.\n\n\n\nValidez ensuite les changements apportés au dépôt Git en créant un commit avec le message \"Ajout des fichiers hello.py et main.py\"."
  },
  {
    "objectID": "tp1.html#ignorer-des-fichiers",
    "href": "tp1.html#ignorer-des-fichiers",
    "title": "TP1 - Premiers pas avec Git",
    "section": "",
    "text": "Vous l’avez surement remarquez, après avoir exécuté le script main.py, un répértoire __pycache__ a été créé dans le répertoire src. Ce répertoire contient des fichiers générés par Python. Nous allons demander à Git de ne pas le suivre.\n\nDéplacez-vous à la racine du répertoire tp1. Vérifier le statut de votre dépôt Git pour voir si le répertoire __pycache__ est toujours mentionné comme étant non suivi par Git.\nCréez un fichier .gitignore à la racine du répertoire tp1 et ajoutez la ligne suivante dans le fichier .gitignore :\n__pycache__\nEnregistrez ensuite le fichier .gitignore.\n\n\n\n\n\n\n\nNote\n\n\n\nLe . devant le nom du fichier .gitignore indique que le fichier est caché, exactement de la même manière que le répertoire .git à la racine de notre dépôt est caché.\n\n\n\nAjoutez ensuite le fichier .gitignore à l’index Git et créez un commit pour valider les changements apportés au dépôt Git. Utilisez le message \"Ajout du fichier .gitignore\".\nVérifiez ensuite le statut de votre dépôt Git pour voir si le répertoire __pycache__ est toujours mentionné comme étant non suivi par Git."
  },
  {
    "objectID": "tp1.html#mettre-à-jour-le-fichier-readme",
    "href": "tp1.html#mettre-à-jour-le-fichier-readme",
    "title": "TP1 - Premiers pas avec Git",
    "section": "",
    "text": "Ouvrez le fichier README.md puis :\n\nNotez dedans les réponses aux questions posées dans les exercices précédents de ce TP.\nListez également les commandes Git que vous avez utilisées dans ce TP et expliquez à quoi elles servent.\nAjoutez ensuite le fichier README.md à l’index Git et créez un commit pour valider les changements apportés au fichier README.md. Utilisez le message \"solution TP1\"."
  },
  {
    "objectID": "cours3.html",
    "href": "cours3.html",
    "title": "Cours 3 - Branches et Fusion",
    "section": "",
    "text": "Dans le dernier cours, nous avons eu un bref aperçu de la notion de branche. Nous avons vu que les branches étaient tout simplement des pointeurs sur des commits et permettaient de travailler sur des versions différentes d’un même projet. Nous allons aborder dans ce cours la manière dont on peut créer et gérer des branches, ainsi que la manière dont on peut fusionner des branches entre elles."
  },
  {
    "objectID": "cours3.html#introduction",
    "href": "cours3.html#introduction",
    "title": "Cours 3 - Branches et Fusion",
    "section": "",
    "text": "Dans le dernier cours, nous avons eu un bref aperçu de la notion de branche. Nous avons vu que les branches étaient tout simplement des pointeurs sur des commits et permettaient de travailler sur des versions différentes d’un même projet. Nous allons aborder dans ce cours la manière dont on peut créer et gérer des branches, ainsi que la manière dont on peut fusionner des branches entre elles."
  },
  {
    "objectID": "cours3.html#la-commande-git-branch",
    "href": "cours3.html#la-commande-git-branch",
    "title": "Cours 3 - Branches et Fusion",
    "section": "2 La commande git branch",
    "text": "2 La commande git branch\nUne fois que vous initialisez un dépôt git, vous avez une branche par défaut qui est créée. Cette branche s’appelle main. Cette branche est la branche principale par défaut de votre projet. La commande git branch permet de lister les branches présentes dans votre dépôt. Vous pouvez l’utiliser de la manière suivante :\n$ git branch\n* main\nL’astérisque devant le nom main indique que c’est la branche sur laquelle vous êtes actuellement. Ici nous n’avons qu’une seule branche, mais il est possible d’en avoir plusieurs. Nous allons voir comment en créer une nouvelle.\nDans un dépôt Git avec une unique branche, l’historique des commits est une succession linéaire de commits. La création de branche permet de créer, comme son nom l’indique, une branche dans l’arbre des commits et ainsi de créer une nouvelle ligne de développement indépendante de la branche principale.\nTravailler avec les branches présente plusieurs avantages:\n\nVous pouvez travailler sur une nouvelle fonctionnalité sans impacter le code de la branche principale.\nCorriger un bug dans le projet sans impacter le code de la branche principale.\nTravailler de manière collaborative sur un projet sans impacter le code de la branche principale.\n\nVous l’aurez compris, les branches sont un élément essentiel de Git car elles permettent de faire évoluer un projet de manière indépendante et sans impacter le code de la branche principale.\n\n\n\n\n\n\nCommandes essentielles\n\n\n\n\ngit branch &lt;nom_branche&gt; permet de créer une nouvelle branche dans votre dépôt, dont le nom est nom_branche.\ngit branch -d &lt;nom_branche&gt; permet de supprimer une branche de votre dépôt, dont le nom est nom_branche.\ngit switch &lt;nom_branche&gt; permet de changer de branche. Vous vous retrouverez sur la branche nom_branche.\n\n\n\n\n2.1 Exemple\nPrenons un petit dépôt Git pour illustrer tout ça. Nous avons un dépôt Git avec deux commits dans la branche main. Nous allons créer une nouvelle branche dev et nous placer dessus. Puis nous allons créer un nouveau commit dans cette branche. Voici le résultat de ces opérations:\n# Historique initial\n$ git log --all --decorate --oneline --graph\n* fdf4E5b (HEAD -&gt; main) Commit 1\n* 5f6b7d5 Commit 0\n\n# Création de la branche dev\n$ git branch dev\n\n# Historique après la création de la branche dev\n$ git log --all --decorate --oneline --graph\n* fdf4E5b (HEAD -&gt; main, dev) Commit 1\n* 5f6b7d5 Commit 0\n\n# On se place sur la branche dev \n$ git switch dev\nBasculement sur la nouvelle branche 'dev'\n\n# Historique après le checkout\n$ git log --all --decorate --oneline --graph\n* fdf4E5b (HEAD -&gt; dev, main) Commit 1\n* 5f6b7d5 Commit 0\n\n# On crée un nouveau commit dans la branche dev, après avoir fait des modifications\n$ git commit -am \"Commit 2\"\n\n# Historique après le commit\n$ git log --all --decorate --oneline --graph\n* 42efefD (HEAD -&gt; dev) Commit 2\n* fdf4E5b (main) Commit 1\n* 5f6b7d5 Commit 0\nOn observe alors que:\n\nLors de la création d’une branche, celle-ci est créée à partir du commit où se situe HEAD (ici le commit Commit 1).\nLorsque l’on se déplace sur une branche, HEAD se déplace sur le dernier commit de la branche (ici le commit Commit 1). HEAD va alors pointer sur la branche dev.\nLorsque l’on crée un nouveau commit dans la branche dev, celui-ci est créé à partir du commit où se situe HEAD (ici le commit Commit 1) de la branche dev et déplace HEAD et dev sur le commit nouvellement créé (ici le commit Commit 2). Le dernier commit de main reste le commit Commit 1."
  },
  {
    "objectID": "cours3.html#le-retour-de-la-commande-git-checkout",
    "href": "cours3.html#le-retour-de-la-commande-git-checkout",
    "title": "Cours 3 - Branches et Fusion",
    "section": "3 Le retour de la commande git checkout",
    "text": "3 Le retour de la commande git checkout\nPrécédemment, nous avons vu que la commande git checkout déplacer HEAD sur un commit spécifique. Mais comme une branche est un pointeur sur un commit, c’est-à-dire qu’une branche référence un commit (son dernier commit en particulier), la commande git checkout &lt;nom_branche&gt; permet également de déplacer HEAD sur le dernier commit de la branche nom_branche.\nLa commande git checkout permet également de créer une nouvelle branche et de se placer directement dessus. C’est pratique dans les cas où vous voulez revenir dans un commit antérieur de votre projet et créer une nouvelle branche à partir de ce commit. Pour cela, on utilise l’option -b de la commande git checkout:\n\n\n\n\n\n\nCommande\n\n\n\ngit checkout &lt;reference_commit&gt; -b &lt;nom_branche&gt; permet de créer une nouvelle branche nom_branche à partir du commit référencé par reference_commit et de se placer dessus.\n\n\n\n3.1 Exemple\nReprenons notre dépôt Git précédent. Nous avons deux commits dans la branche main et un commit dans la branche dev. Nous allons nous placer sur le commit Commit 0 et créer une nouvelle branche feature à partir de ce commit. Voici le résultat de ces opérations:\n# Historique initial\n$ git log --all --decorate --oneline --graph\n* 42efefD (HEAD -&gt; dev) Commit 2\n* fdf4E5b (main) Commit 1\n* 5f6b7d5 Commit 0\n\n# On se place sur le commit 0 et on crée une nouvelle branche feature\n$ git checkout 5f6b7d5 -b feature\nBasculement sur la nouvelle branche 'feature'\n\n# Historique après le checkout\n$ git log --all --decorate --oneline --graph\n* 42efefD (dev) Commit 2\n* fdf4E5b (main) Commit 1\n* 5f6b7d5 (HEAD -&gt; feature) Commit 0\n\n\n\n\n\n\nNote\n\n\n\nPuisque git checkout a besoin d’une référence à un commit pour pouvoir déplacer HEAD, les références suivantes auraient également fonctionné:\n\ngit checkout 5f6b7d5 -b feature\ngit checkout main^ -b feature\ngit checkout main~1 -b feature\ngit checkout dev^^ -b feature\ngit checkout dev~2 -b feature\ngit checkout HEAD^^ -b feature\ngit checkout HEAD~2 -b feature"
  },
  {
    "objectID": "cours3.html#fusionner-des-branches",
    "href": "cours3.html#fusionner-des-branches",
    "title": "Cours 3 - Branches et Fusion",
    "section": "4 Fusionner des branches",
    "text": "4 Fusionner des branches\nFusionner deux branches permet de combiner les modifications apportées dans une branche avec une autre branche. La fusion de deux branches se fait toujours dans le sens d’une branche vers une autre branche. On appelera la branche qui reçoit les modifications branche de destination et la branche qui fournit les modifications branche source.\nConcrètement, l’opération de fusion consiste créer un nouveau commit, appelé commit de fusion dans la branche de destination. Ce commit aura comme parent le dernier commit de la branche destination et de la branche source. Faire une fusion permet donc de fusionner deux historiques de commits en un seul.\n\n\n\n\n\n\nCommande\n\n\n\ngit merge &lt;nom_branche&gt; permet de fusionner la branche nom_branche dans la branche courante.\n\n\n\n4.1 Exemple\nPrenons notre dépôt exemple tel qu’il était avant de créer la branche feature. Nous avons deux commits dans la branche main et un commit supplémentaire dans la branche dev. Dans un premier temps, nous allons créer un commit dans main, ensuite allons fusionner la branche dev dans la branche main. Dans notre exemple dev sera la branch source et main la branche de destination. Voici le résultat de ces opérations:\n# Historique initial\n$ git log --all --decorate --oneline --graph\n* 42efefD (HEAD -&gt; dev) Commit 2\n* fdf4E5b (main) Commit 1\n* 5f6b7d5 Commit 0\n\n# On se place d'abord sur main\n$ git switch main\nBasculement sur la branche 'main'\n\n# On crée un nouveau commit dans main\n$ git commit -am \"Commit 3\"\n\n# Historique après le commit\n$ git log --all --decorate --oneline --graph\n* 42efefD (dev) Commit 2\n| * 8ba1953 (HEAD -&gt; main) Commit 3\n|/\n* fdf4E5b Commit 1\n* 5f6b7d5 Commit 0\n\n# On fusionne la branche dev dans la branche main\n$ git merge dev -m \"Commit 4(fusion)\"\n\n# Historique après la fusion\n$ git log --all --decorate --oneline --graph\n*   efde87b (HEAD -&gt; main) Commit 4(fusion)\n|\\\n| * 42efefD (dev) Commit 2\n* | 8ba1953 Commit 3\n|/\n* fdf4E5b Commit 1\n* 5f6b7d5 Commit 0\n\n\n\n\n\n\nImportant\n\n\n\nDans la pratique, une fois satisfait du travail effectué dans une branche, on la supprime. Cela permet de garder un historique propre et de ne pas avoir trop de branches dans le dépôt. Pour supprimer une branche, on utilise la commande git branch -d &lt;nom_branche&gt;."
  },
  {
    "objectID": "cours3.html#réorganiser-lhistorique-avec-git-rebase",
    "href": "cours3.html#réorganiser-lhistorique-avec-git-rebase",
    "title": "Cours 3 - Branches et Fusion",
    "section": "5 Réorganiser l’historique avec git rebase",
    "text": "5 Réorganiser l’historique avec git rebase\n\n\n\n\n\n\nCommande\n\n\n\nGit rebase est une commande qui permet de déplacer ou combiner une séquence de commits vers une nouvelle base (commit). Elle réécrit l’historique du projet en créant de nouveaux commits pour chaque commit de la branche originale.\nElle permet d’avoir un historique linéaire.\n\n\n\nComment ça fonctionne réellement :\n\n\ngit rebase prend les commits d’une branche et les rejoue sur une autre branche\nIl crée de nouveaux commits avec de nouveaux hashes, même si le contenu est identique\nIl modifie l’historique du dépôt en créant une nouvelle ligne de commits\n\n\nDifférence principale avec merge :\n\n\nmerge crée un nouveau commit qui combine les changements des deux branches.\nrebase réécrit l’historique en déplaçant la base de votre branche Le résultat final en termes de contenu est le même, mais l’historique est différent.\n\n\nQuand utiliser chaque commande :\n\n\nmerge : pour intégrer des changements tout en préservant l’historique exact\nrebase : pour garder un historique linéaire et plus propre, particulièrement utile pour les branches de fonctionnalités avant de les fusionner dans main\n\n\n\n\n\n\n\nImportant\n\n\n\nN’utilisez jamais rebase sur des commits qui ont déjà été publiés et partagés avec d’autres développeurs, car cela peut créer des problèmes de synchronisation pour l’équipe.\n\n\nReprenons notre exemple. On suppose que l’état de notre dépôt est le suivant:\n# Historique actuel\n$ git log --all --decorate --oneline --graph\n* 80f914d (HEAD -&gt; feature) Commit 6\n* e045507 Commit 5\n| * 830e010 (main) Commit 8\n| * 855796a Commit 7\n|/  \n*   e1838dc (dev) Commit 4(fusion)\n|\\  \n| * fdf4723 Commit 2\n* | 8ba1953 Commit 3\n|/  \n* fdf4E5b Commit 1\n* 5f6b7d5 Commit 0\nÀ partir du Commit 4(fusion), une branche feature a été créé. Les commits Commit 5 et Commit 6 ont été réalisés dans feature tandis que Commit 7 et Commit 8 ont été faits dans main. La branche courante est feature.\nNous voudrions par la suite que main intègre les modifications apportés dans la branche feature avec un rebase. Ici main est donc notre branche de destination et feature notre branche source. On suppose que les commits de feature ne présentent aucun conflits avec ceux de main. Voici comment procéder:\n# On se place sur la branche main\n$ git switch main\nBasculement sur la branche 'main'\n\n# On effectue le rebase \n$ git rebase feature\n\n# Historique après le rebase\n$ git log --all --decorate --oneline --graph\n* 4644c80 (HEAD -&gt; main) Commit 8\n* 7d6c207 Commit 7\n* 830e010 (feature) Commit 6\n* e045507 Commit 5\n*   e1838dc (dev) Commit 4(fusion)\n|\\\n| * fdf4723 Commit 2\n* | 8ba1953 Commit 3\n|/\n* fdf4E5b Commit 1\n* 5f6b7d5 Commit 0\nRemarquez que les hash des Commit 7 et Commit 8 ont changé. En effet, ce sont de nouveaux commits mais avec exactement les mêmes informations avant le rebase. Vous pouvez voir rebase comme un couper/coller.\nLe rebase de main dans feature coupe tous les commits de main qui ne sont pas encore dans feature et les colle après feature. C’est-à-dire que main est déplacé sur le dernier commit de feature et que les commits de main sont recopiés après feature, ainsi tous les commits de feature ont été intégrés dans main.\n\n\n\n\n\n\nEn somme\n\n\n\ngit rebase &lt;branche_source&gt; permet de recopier tous les commits de la branche courante sur la branche branche_source.\ngit rebase &lt;branche_source&gt; &lt;branche_destination&gt; permet de recopier tous les commits de la branche branche_source sur la branche branche_destination et déplace HEAD sur la branche branche_destination."
  },
  {
    "objectID": "cours3.html#conflits-de-fusion",
    "href": "cours3.html#conflits-de-fusion",
    "title": "Cours 3 - Branches et Fusion",
    "section": "6 Conflits de fusion",
    "text": "6 Conflits de fusion\nLes conflits de fusion (ou merge conflicts en anglais) surviennent lorsqu’il y a des modifications concurrentes et incompatibles sur un même fichier dans un système de contrôle de version comme Git. Cela se produit généralement lorsque deux branches différentes ont modifié la même partie du code et que Git ne peut pas résoudre automatiquement les différences.\nEn d’autres termes, il y a conflit lorsque vous essayez fusionner deux branches alors qu’un fichier contient deux versions différentes sur une ou plusieurs même lignes.\nLorsque Git détecte un conflit de fusion, il marque le fichier conflictuel et vous devez le résoudre manuellement. Voici un scenario type dans lequel les conflits peuvent apparaître et comment les résoudre.\n\n6.1 Scenario type de conflit de fusion\n\nVous lancez une fusion par exemple d’une branche dev dans une branche main.\nSi Git détecte des conflits, il vous informera que des conflits de fusion se sont produits et il vous indiquera les fichiers conflictuels. À ce stade, Git va tout simplement suspendre la fusion.\nVous devez ouvrir chaque fichier conflictuel dans un éditeur de texte. À l’intérieur du fichier, vous verrez des marqueurs de conflit qui ressemblent à ceci :\n\n# Ici se trouvent les modifications de la branche `dev` (branche source)\nLa partie entre &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD et ======= correspond aux modifications de la branche principale, et la partie entre ======= et &gt;&gt;&gt;&gt;&gt;&gt;&gt; dev correspond aux modifications de la branche que nous essayons de fusionner.\nPrenons alors un exemple pour illustrer tout ça. On suppose que l’on a l’historique suivant:\n* e0397cd (HEAD -&gt; dev) Commit 3\n| * a518e66 (main) Commit 2\n|/\n* 6177b18 Commit 1\n* e0dbacd Commit 0\nDans ce dépôt il n’y a qu’un unique fichier README.md dans lequel on a ajouté pour chaque commit le message du commit. C’est-à-dire qu’au moment du Commit 0, le fichier README.md contenait uniquement la ligne Commit 0. Au moment du Commit 1, le fichier README.md contenait une ligne Commit 0 et une ligne Commit 1. Et actuellement, voici le contenu du fichier README.md:\nDans main:\nCommit 0\nCommit 1\nCommit 2\nDans dev:\nCommit 0\nCommit 1\nCommit 3\nOn remarque bien qu’à la ligne 3, les deux fichiers contiennent des informations différentes. Essayons donc de fusionner dev dans main et observons le résultat.\n$ git switch main\nBasculement sur la branche 'main'\n\n$ git merge dev\nFusion automatique de README.md\nCONFLIT (contenu) : Conflit de fusion dans README.md\nLa fusion automatique a échoué ; réglez les conflits et validez le résultat.\nGit nous indique que le fichier conflictuel est le fichier README.md. Ouvrons-le et observons son contenu:\nCommit 0\nCommit 1\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\nCommit 2\n=======\nCommit 3\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev\nLa ligne Commit 2 est la ligne de la branche main et la ligne Commit 3 est la ligne de la branche dev.\n\n\n6.2 Résolution des conflits\nVous devez modifier manuellement le contenu du fichier pour résoudre les conflits. Vous pouvez choisir de garder uniquement les modifications de la branche principale, uniquement les modifications de la branche à fusionner, ou combiner les deux selon vos besoins. Supprimez également les marqueurs de conflit &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD, ======= et &gt;&gt;&gt;&gt;&gt;&gt;&gt; dev une fois que vous avez terminé la résolution.\nAprès avoir résolu le conflit, il vous faut enregistrer les modifications et ajouter le fichier résolu à la zone d’index. Vous pouvez ensuite finaliser la fusion en effectuant un commit.\n\n\n\n\n\n\nWarning\n\n\n\nIl est important de noter que les conflits de fusion peuvent être complexes et nécessitent souvent une compréhension approfondie du code et des intentions des modifications. Il est recommandé de prendre le temps d’analyser soigneusement les conflits et de consulter les membres de l’équipe si nécessaire pour prendre des décisions éclairées lors de la résolution des conflits.\n\n\nReprenons notre exemple. Nous allons résoudre le conflit en gardant les deux lignes. Voici le résultat:\nCommit 0\nCommit 1\nCommit 2\nCommit 3\nNous pouvons alors ajouter le fichier résolu à la zone d’index et finaliser la fusion en effectuant un commit.\n# Après la résolution du conflit, on ajoute le fichier résolu à la zone d'index\n$ git add README.md\n\n# On finalise la fusion en effectuant un commit\n$ git commit -m \"Commit 4(fusion)\"\n\n# Historique après la fusion\n$ git log --all --decorate --oneline --graph\n*   1f2b6b6 (HEAD -&gt; main) Commit 4(fusion)\n|\\\n| * e0397cd (dev) Commit 3\n* | a518e66 Commit 2\n|/\n* 6177b18 Commit 1\n* e0dbacd Commit 0"
  },
  {
    "objectID": "cours3.html#pour-aller-plus-loin",
    "href": "cours3.html#pour-aller-plus-loin",
    "title": "Cours 3 - Branches et Fusion",
    "section": "7 Pour aller plus loin",
    "text": "7 Pour aller plus loin\n\n\n\n\n\n\nRessources supplémentaires\n\n\n\n\nDocumentation officielle de Git sur les branches\nDocumentation officielle de Git sur la fusion\nDocumentation officielle de Git sur le rebase"
  },
  {
    "objectID": "cours1.html",
    "href": "cours1.html",
    "title": "Cours 1 - Introduction au versionnage",
    "section": "",
    "text": "Le versionnage ou la gestion de version (version control en anglais) est un processus qui consiste à enregistrer les modifications apportées à un fichier ou un ensemble de fichiers au fil du temps afin de pouvoir y accéder ultérieurement. Le versionnage est utilisé dans de nombreux domaines, notamment le développement logiciel, la gestion de projet, la gestion de contenu, etc.\nDans le cadre du développement logiciel, cette pratique permet de suivre l’évolution d’un projet de manière organisée et collaborative.\n\n\n\n\n\n\nDéfinitions\n\n\n\nLe versionnage est un processus qui consiste à enregistrer les modifications apportées à un fichier ou un ensemble de fichiers au fil du temps afin de pouvoir y accéder ultérieurement.\nUne version est l’état d’un fichier ou d’un ensemble de fichiers à un moment donné.\n\n\n\n\nLe versionnage permet de répondre à plusieurs besoins essentiels dans le développement logiciel, notamment:\n\nGestion des modifications : Le versionnage permet de suivre les modifications apportées au code source d’un projet. Il permet de répondre à des questions telles que :\n\nQuels sont les changements apportés au code source ?\nQuand ont-ils été apportés ?\nQui les a apportés ?\nPourquoi ont-ils été apportés ? etc.\n\nCollaboration : Le versionnage permet à plusieurs développeurs de travailler sur le même projet en même temps. Il permet de répondre à des questions telles que :\n\nComment les développeurs peuvent-ils travailler ensemble sur le même projet ?\nComment peuvent-ils partager leurs modifications ?\nComment peuvent-ils fusionner leurs modifications ? etc.\n\nTraçabilité : Le versionnage permet de suivre l’évolution d’un projet au fil du temps. Il permet de répondre à des questions telles que :\n\nQuels sont les changements apportés au projet ?\nQuand ont-ils été apportés ?\nQui les a apportés ?\nPourquoi ont-ils été apportés ? etc.\n\nSauvegarde : Le versionnage permet de sauvegarder les modifications apportées au code source d’un projet. Il permet de répondre à des questions telles que :\n\nComment revenir à une version antérieure du projet ?\nComment récupérer une version supprimée du projet ? etc.\n\nReproductibilité : Le versionnage permet de reproduire un projet dans un état donné. Il permet de répondre à des questions telles que :\n\nComment reproduire un projet dans un état donné ?\nComment reproduire un projet dans un état donné à une date donnée ? etc.\n\nBonnes pratiques : Le versionnage permet d’appliquer des bonnes pratiques de développement logiciel. Il permet de répondre à des questions telles que :\n\nComment maintenir un historique de version propre et organisé ?\nComment documenter les modifications apportées au code source ? etc.\n\n\n\n\n\nLe versionnage est basé sur les concepts essentiels suivants :\n\nDépôt (Repository) : Un dépôt est un espace de stockage qui contient les fichiers d’un projet ainsi que l’historique des modifications apportées à ces fichiers. Il peut être local ou distant.\nCommit : Un commit est une modification apportée à un ou plusieurs fichiers d’un projet. Il est identifié par un identifiant unique appelé hash.\nHistorique des commits (Commit tree) : L’historique des commits est la liste des commits qui ont été apportés à un projet. Il permet de suivre l’évolution d’un projet au fil du temps.\nBranche (Branch) : Une branche est une ligne de développement indépendante. Elle permet de travailler sur une fonctionnalité ou une modification sans affecter la branche principale du projet.\nFusion (Merge) : Une fusion est l’opération qui consiste à intégrer les modifications apportées à une branche dans une autre branche.\n\nLe graphique suivant illustre ces concepts :  \n\n\n\n\n\n\nVocabulaire\n\n\n\nLes termes suivants sont couramment utilisés dans le contexte du versionnage :\n\nDépôt distant (Remote repository) : Un dépôt distant est un dépôt qui est stocké sur un serveur distant. Il permet de partager les modifications apportées à un projet avec d’autres développeurs.\nDépôt local (Local repository) : Un dépôt local est un dépôt qui est stocké sur la machine d’un développeur. Il permet de travailler sur un projet sans connexion à un serveur distant.\nClone : Un clone est une copie d’un dépôt distant sur un dépôt local. Il permet de travailler sur un projet sans connexion à un serveur distant.\nPull : Un pull est l’opération qui consiste à récupérer les modifications apportées à un dépôt distant et les fusionner avec un dépôt local.\nPush : Un push est l’opération qui consiste à envoyer les modifications apportées à un dépôt local vers un dépôt distant.\nPull request : Une pull request est une demande de fusion de modifications apportées à un dépôt distant. Elle permet de demander à un propriétaire de dépôt de fusionner les modifications apportées à un dépôt distant avec le dépôt d’origine.\nTag : Un tag est un identifiant symbolique qui permet de marquer un commit. Il est généralement utilisé pour marquer les versions stables d’un projet.\nConflit : Un conflit est une situation dans laquelle deux modifications concurrentes affectent le même fichier. Il nécessite une intervention manuelle pour être résolu.\n\n\n\n\n\n\nPour mettre en place un processus de versionnage, il est nécessaire d’utiliser un outil de gestion de version.\nUn outil de gestion de version est un logiciel qui permet de gérer les différentes versions d’un ensemble de fichiers (code source, documentation, etc.). Les outils de gestion de version sont couramment utilisés dans les projets de développement de logiciels pour suivre les modifications apportées au code source et pour faciliter la collaboration entre les membres d’une équipe.\nIls permmettent d’appliquer plus ou moins les principes essentiels du versionnage: stocker chaque version d’un fichier, d’enregistrer les modifications apportées à chaque version, de fusionner des versions différentes, de suivre l’historique des modifications, de revenir en arrière sur une version antérieure, et de travailler en collaboration avec d’autres personnes.\n\n\n\nIl existe deux types d’outils de gestion de version : les outils de gestion de version dits centralisés et les outils de gestion de version dits décentralisés.\n\n\n\n\n\n\nRemarque\n\n\n\nDans ce cours nous allons utiliser l’outil de gestion de version décentralisé Git. Mais il est tout de même important de comprendre les différences entre les deux types d’outils.\n\n\n\n\nLes outils de gestion de version centralisés sont basés sur un modèle client-serveur. Ils utilisent un dépôt centralisé pour stocker les fichiers d’un projet et l’historique des modifications apportées à ces fichiers.\n\nLes développeurs travaillent sur une copie locale du dépôt centralisé.\nIls peuvent récupérer les modifications apportées au dépôt centralisé et les fusionner avec leur copie locale.\nIls peuvent également envoyer les modifications apportées à leur copie locale vers le dépôt centralisé.\n\nLes outils de gestion de version centralisés les plus populaires sont Subversion (SVN), Perforce, et ClearCase.\nLe graphique suivant illustre le fonctionnement d’un outil de gestion de version centralisé :\n\n\n\n\n\ngraph LR\n    A[Alice] -- Push --&gt; B((Dépôt centralisé))\n    B -- Pull --&gt; A\n    C[Bob] -- Push --&gt; B\n    B -- Pull --&gt; C\n\n\n\n\n\n\nAlice et Bob travaillent sur le même projet dont la gestion de version se fait par un outil de gestion de version centralisé\n\n\n\nAlice effectue un changement puis elle envoie ses modifications vers le dépôt central.\nLe dépôt central est mis à jour.\nBob récupère la dernière version du projet (qui intègre les changements d’Alice) en mettant à jour sa copie locale du dépôt central.\nSi il y a des conflits, Bob doit les résoudre manuellement avant de pouvoir envoyer ses modifications.\n\n\n\n\n\n\n\nAvantages\n\n\n\n\nContrôle centralisé : Un seul dépôt central offre un contrôle plus strict sur les modifications et les versions.\nVisibilité globale : Facilité de suivi des changements, historique global des versions et gestion des conflits simplifiée.\nCollaboration facilitée :Les équipes travaillent sur la même base de code, favorisant la collaboration et la cohérence du projet.\n\n\n\n\n\n\n\n\n\nInconvénients\n\n\n\n\nDépendance au serveur central : En cas de panne du serveur central, l’accès aux versions et la collaboration peuvent être perturbés.\nBranchements complexes : La gestion de branches peut être plus complexe, avec un risque accru de conflits lors des fusions.\nPerformance dépendante du réseau : L’accès et la performance peuvent être affectés si l’équipe travaille à distance ou avec une connexion lente.\nImpossibilité de travailler hors ligne : Les développeurs ne peuvent pas travailler hors ligne, ce qui peut être un problème pour les équipes distribuées.\n\n\n\n\n\n\n\nOn parle aussi d’outil de gestion distribué.\n\nIls utilisent un dépôt local pour stocker les fichiers d’un projet et l’historique des modifications apportées à ces fichiers.\nLes développeurs travaillent sur une copie locale du dépôt distant. Ils peuvent récupérer les modifications apportées au dépôt distant et les fusionner avec leur copie locale.\nIls peuvent également envoyer les modifications apportées à leur copie locale vers le dépôt distant.\n\nLes outils de gestion de version décentralisés les plus populaires sont Git et Mercurial\nLe graphique suivant illustre le fonctionnement d’un outil de gestion de version décentralisé :\n\n\n\n\n\n    graph LR\n        A[Dépôt local d'Alice] -- Push --&gt; B((Dépôt distant))\n        B -- Pull --&gt; A\n        C[Dépôt local de Bob] -- Push --&gt; B\n        B -- Pull --&gt; C\n        D[Alice] -- Commit --&gt; A\n        E[Bob] -- Commit --&gt; C\n\n\n\n\n\n\n\n\n\nAlice effectue un changement puis elle soumet ses modifications dans son dépôt local.\nElle pousse (push) ces modification vers le dépôt distant.\nLe dépôt distant est mis à jour.\nBob récupère la dernière version du projet (qui intègre les changements d’Alice) en mettant à jour son dépôt local par rapport au dépôt distant. (pull)\n\nC’est comme si chacun avait son propre dépôt centralisé.\n\n\n\n\n\n\nAvantages\n\n\n\n\nTravail en mode déconnecté : Les développeurs peuvent travailler en mode déconnecté sans être connectés en permanence à un serveur central.\nMeilleure sécurité : Les copies locales des fichiers sont stockées sur l’ordinateur du développeur, ce qui rend le système plus sûr et plus résistant aux attaques.\nMeilleure flexibilité : Les développeurs peuvent facilement créer des branches, expérimenter et fusionner des modifications sans affecter le code source principal.\nPerformances améliorées : Les opérations locales sont beaucoup plus rapides que les opérations de synchronisation avec un serveur central.\n\n\n\n\n\n\n\n\n\nInconvénients\n\n\n\n\nComplexité accrue : Les développeurs doivent apprendre à gérer les dépôts locaux et distants, ce qui peut être plus complexe.\nVisibilité limitée : Les développeurs ne peuvent pas voir les modifications apportées par d’autres développeurs tant qu’ils n’ont pas synchronisé leurs dépôts locaux avec le dépôt distant.\nGestion des conflits plus complexe : Les conflits peuvent être plus difficiles à gérer, car les développeurs doivent les résoudre localement avant de les pousser vers le dépôt distant.\n\n\n\n\n\n\n\n\nDans ce cours, nous allons mettre en pratique les concepts de base du versionnage en utilisant l’outil de gestion de version décentralisé Git. Il est actuellement l’outil de gestion de version le plus utilisé, en particulier dans les projets open source, grâce à sa facilité d’utilisation, sa rapidité et sa flexibilité.\n\n\n\n\n\n\nNote\n\n\n\nGit a été créé en 2005 par Linus Torvalds, le créateur du noyau Linux. À l’époque, il cherchait un outil de gestion de version pour le développement du noyau Linux, mais n’était pas satisfait des outils existants tels que BitKeeper.\nTorvalds a donc décidé de créer son propre outil de gestion de version, en s’appuyant sur les principes de conception du noyau Linux.\nLe développement de Git a été principalement motivé par la nécessité de gérer efficacement le code source du noyau Linux, qui est un projet très complexe et en constante évolution avec des milliers de développeurs à travers le monde.\nAu fil des ans, Git est devenu de plus en plus populaire auprès des développeurs et des entreprises. En 2008, le projet Git a été adopté par la communauté open-source et est rapidement devenu un outil de gestion de version standard pour de nombreux projets open-source.\nAujourd’hui, Git est largement utilisé dans l’industrie du développement de logiciels pour la gestion de versions de code source, la collaboration en équipe, et l’intégration continue. Les plateformes d’hébergement de code source telles que GitHub, GitLab et Bitbucket sont devenues des outils incontournables pour les projets de développement de logiciels, en grande partie grâce à l’adoption massive de Git.\n\n\n\n\nIl existe de nombreuses manières différentes d’utiliser Git. Il y a les outils originaux en ligne de commande et il y a de nombreuses interfaces graphiques avec des capacités variables. La plupart des IDE récents intègre déjà l’utilisation d’outils gestion de version.\nDans ce cours, nous utiliserons Git en ligne de commande.\n\nTout d’abord, la ligne de commande est la seule interface qui permet de lancer toutes les commandes Git (la plupart des interfaces graphiques simplifient l’utilisation en ne couvrant qu’un sous-ensemble des fonctionnalités de Git).\nSi vous savez comment utiliser la version en ligne de commande, vous serez à même de comprendre comment fonctionne la version graphique, tandis que l’inverse n’est pas nécessairement vrai.\nDe plus, le choix d’un outil graphique est sujet à des goûts personnels, mais tous les utilisateurs auront les commandes installées et utilisables.\n\nToutes les commandes Git s’utilisent de la manière suivante:\ngit &lt;commande&gt; [options]\nIl faudra alors taper dans un terminal git suivi du nom de la commande et éventuellement suivis d’autres options que nous allons voir plus tard.\nPar exemple la commande init qui permet d’initialiser un dépôt Git et s’utilise de la manière suivante:\ngit init\n\n\n\n\n\n\nNote\n\n\n\n\nDans toute la suite de ce cours, surtout en TP, nous allons utiliser Git en ligne de commande. Pour ce faire, vous devez ouvrir un terminal sur votre machine.\n\nSi vous êtes sur Windows, vous pouvez utiliser Git Bash pour exécuter les commandes Git.\nSi vous êtes sur Linux ou Mac, vous pouvez utiliser le terminal intégré à votre système d’exploitation.\n\nDevant chaque commande, vous verrez le symbole $. Ce symbole représente le prompt de votre terminal. Vous ne devez pas le copier lorsque vous exécutez les commandes Git.\nLes lignes de commandes précédées du symbole # sont des commentaires. Vous ne devez pas les copier lorsque vous exécutez les commandes.\n\n\n\n\n\n\nUne fois que vous avez créé un dépôt Git, l’outil va créer un répertoire .git qui contient tous les fichiers nécessaires au fonctionnement de Git. Ce répertoire est appelé dépôt Git ou dépôt local. Il est très important de ne pas modifier ou supprimer ce répertoire.\nGit va alors retracer l’historique des modifications apportées aux fichiers du projet en travaillant avec trois zones différentes:\n\nla zone de travail (working directory)\n\nc’est le répertoire dans lequel sont stockés physiquement vos fichiers. C’est le répertoire dans lequel vous travaillez.\n\nla zone d’index (staging area)\n\nc’est une zone intermédiaire entre la zone de travail et la zone de dépôt.\nelle permet de marquer les modifications à envoyer lors du prochain commit.\nelle est matérialisée dans .git/index\n\nla zone de dépôt (git repository)\n\nc’est le répertoire dans lequel sont stockés les fichiers de votre projet tels qu’ils étaient lors de votre dernier commit.\nDans ce répertoire, Git stocke l’historique des modifications apportées à votre projet.\n\n\nLes différentes commandes Git permettent de passer d’une zone à une autre. On peut voir le dépôt Git comme étant une base de données qui garde de manière compressée toutes les versions (que vous voulez que Git conserve) de votre projet. Le diagramme suivant montre comment passer un fichier d’une zone à une autre.\n\n\n\n\n\nstateDiagram-v2\n    s1 : Git repository\n    s2 : Staging area\n    s3 : Working directory\n    s1 --&gt; s2 : git reset\n    s2 --&gt; s1 : git commit\n    s2 --&gt; s3 : git checkout\n    s3 --&gt; s2 : git add\n\n\n\n\n\n\nLa commande git status permet savoir quels fichiers sont différents d’une zone à une autre.\n$ git status\n# On branch main\n# Changes to be committed:\n#   (use \"git reset HEAD ...\" to unstage)\n#\n#   modified:   accounts/forms.py\n#   modified:   accounts/models.py\n#\n# Changes not staged for commit:\n#   (use \"git add ...\" to update what will be committed)\n#   (use \"git checkout -- ...\" to discard changes in working directory)\n#\n#   modified:   accounts/urls.py\n#   modified:   accounts/views.py\nIci, la réponse de git status indique par exemple que les fichiers:\n\naccounts/forms.py et accounts/models.py sont indexés dans la zone de staging et attendent d’être ajouté dans le dépôt.\naccounts/urls.py et accounts/views.py ne sont pas encore dans la zone de staging et attendent d’y être ajoutés.\n\nLe processus usuel est donc le suivant:\n\nOn crée/modifie un fichier dans la zone de travail\nOn l’ajoute dans la zone d’index avec git add.\nEnsuite, on soumets les modifications apportés au dépôt git avec git commit.\n\n\n\n\nVoici les commandes de base de Git dans diverses situations telles qu’elles sont listées dans l’accueil de l’outil :\nDémarrer un dépôt Git\n\nclone Cloner un dépôt dans un nouveau répertoire\ninit Créer un dépôt Git vide ou réinitialiser un existant\n\nTavailler sur la modification actuelle\n\nadd Ajouter le contenu de fichiers dans l’index\n\nadd -u ajouter tous les fichiers modifiés et supprimés (mais pas les “untracked”)\n\nmv Déplacer ou renommer un fichier, un répertoire, ou un lien symbolique\nrestore Restaurer des fichiers\nrm Supprimer des fichiers de la copie de travail et de l’index\n\nExaminer l’historique et l’état du dépôt\n\ndiff Afficher les changements entre les commits\nlog Afficher l’historique des commits\nstatus Afficher l’état de la répertoire de travail\n\nAgrandir, marquer et modifier votre historique\n\nbranch Lister, créer ou supprimer des branches\ncommit Enregistrer les modifications dans le dépôt\nmerge Fusionner deux ou plusieurs historiques de développement ensemble\nrebase Déplacer un ensemble de commits vers un autre point de base\nreset Réinitialiser la HEAD courante à l’état spécifié\nswitch Basculer de branche\n\nCollaborer\n\nfetch Télécharger les objets et références depuis un autre dépôt\npull Rapatrier et intégrer un historique depuis un dépôt distant\npush Pousser l’histoire local vers un dépôt distant\n\nSi l’on ne se souvient pas de toutes les commandes\n\nhelp Affiche l’aide\n\nUn aide mémoire est également à votre disposition ici.\n\n\n\n\n\n\nTip\n\n\n\nDans le premier TP associé à ce cours, nous allons installer, configurer Git et faire nos premiers pas avec l’outil."
  },
  {
    "objectID": "cours1.html#pourquoi-le-versionnage",
    "href": "cours1.html#pourquoi-le-versionnage",
    "title": "Cours 1 - Introduction au versionnage",
    "section": "",
    "text": "Le versionnage permet de répondre à plusieurs besoins essentiels dans le développement logiciel, notamment:\n\nGestion des modifications : Le versionnage permet de suivre les modifications apportées au code source d’un projet. Il permet de répondre à des questions telles que :\n\nQuels sont les changements apportés au code source ?\nQuand ont-ils été apportés ?\nQui les a apportés ?\nPourquoi ont-ils été apportés ? etc.\n\nCollaboration : Le versionnage permet à plusieurs développeurs de travailler sur le même projet en même temps. Il permet de répondre à des questions telles que :\n\nComment les développeurs peuvent-ils travailler ensemble sur le même projet ?\nComment peuvent-ils partager leurs modifications ?\nComment peuvent-ils fusionner leurs modifications ? etc.\n\nTraçabilité : Le versionnage permet de suivre l’évolution d’un projet au fil du temps. Il permet de répondre à des questions telles que :\n\nQuels sont les changements apportés au projet ?\nQuand ont-ils été apportés ?\nQui les a apportés ?\nPourquoi ont-ils été apportés ? etc.\n\nSauvegarde : Le versionnage permet de sauvegarder les modifications apportées au code source d’un projet. Il permet de répondre à des questions telles que :\n\nComment revenir à une version antérieure du projet ?\nComment récupérer une version supprimée du projet ? etc.\n\nReproductibilité : Le versionnage permet de reproduire un projet dans un état donné. Il permet de répondre à des questions telles que :\n\nComment reproduire un projet dans un état donné ?\nComment reproduire un projet dans un état donné à une date donnée ? etc.\n\nBonnes pratiques : Le versionnage permet d’appliquer des bonnes pratiques de développement logiciel. Il permet de répondre à des questions telles que :\n\nComment maintenir un historique de version propre et organisé ?\nComment documenter les modifications apportées au code source ? etc."
  },
  {
    "objectID": "cours1.html#concepts-de-base-du-versionnage",
    "href": "cours1.html#concepts-de-base-du-versionnage",
    "title": "Cours 1 - Introduction au versionnage",
    "section": "",
    "text": "Le versionnage est basé sur les concepts essentiels suivants :\n\nDépôt (Repository) : Un dépôt est un espace de stockage qui contient les fichiers d’un projet ainsi que l’historique des modifications apportées à ces fichiers. Il peut être local ou distant.\nCommit : Un commit est une modification apportée à un ou plusieurs fichiers d’un projet. Il est identifié par un identifiant unique appelé hash.\nHistorique des commits (Commit tree) : L’historique des commits est la liste des commits qui ont été apportés à un projet. Il permet de suivre l’évolution d’un projet au fil du temps.\nBranche (Branch) : Une branche est une ligne de développement indépendante. Elle permet de travailler sur une fonctionnalité ou une modification sans affecter la branche principale du projet.\nFusion (Merge) : Une fusion est l’opération qui consiste à intégrer les modifications apportées à une branche dans une autre branche.\n\nLe graphique suivant illustre ces concepts :  \n\n\n\n\n\n\nVocabulaire\n\n\n\nLes termes suivants sont couramment utilisés dans le contexte du versionnage :\n\nDépôt distant (Remote repository) : Un dépôt distant est un dépôt qui est stocké sur un serveur distant. Il permet de partager les modifications apportées à un projet avec d’autres développeurs.\nDépôt local (Local repository) : Un dépôt local est un dépôt qui est stocké sur la machine d’un développeur. Il permet de travailler sur un projet sans connexion à un serveur distant.\nClone : Un clone est une copie d’un dépôt distant sur un dépôt local. Il permet de travailler sur un projet sans connexion à un serveur distant.\nPull : Un pull est l’opération qui consiste à récupérer les modifications apportées à un dépôt distant et les fusionner avec un dépôt local.\nPush : Un push est l’opération qui consiste à envoyer les modifications apportées à un dépôt local vers un dépôt distant.\nPull request : Une pull request est une demande de fusion de modifications apportées à un dépôt distant. Elle permet de demander à un propriétaire de dépôt de fusionner les modifications apportées à un dépôt distant avec le dépôt d’origine.\nTag : Un tag est un identifiant symbolique qui permet de marquer un commit. Il est généralement utilisé pour marquer les versions stables d’un projet.\nConflit : Un conflit est une situation dans laquelle deux modifications concurrentes affectent le même fichier. Il nécessite une intervention manuelle pour être résolu."
  },
  {
    "objectID": "cours1.html#outils-de-gestion-de-version",
    "href": "cours1.html#outils-de-gestion-de-version",
    "title": "Cours 1 - Introduction au versionnage",
    "section": "",
    "text": "Pour mettre en place un processus de versionnage, il est nécessaire d’utiliser un outil de gestion de version.\nUn outil de gestion de version est un logiciel qui permet de gérer les différentes versions d’un ensemble de fichiers (code source, documentation, etc.). Les outils de gestion de version sont couramment utilisés dans les projets de développement de logiciels pour suivre les modifications apportées au code source et pour faciliter la collaboration entre les membres d’une équipe.\nIls permmettent d’appliquer plus ou moins les principes essentiels du versionnage: stocker chaque version d’un fichier, d’enregistrer les modifications apportées à chaque version, de fusionner des versions différentes, de suivre l’historique des modifications, de revenir en arrière sur une version antérieure, et de travailler en collaboration avec d’autres personnes."
  },
  {
    "objectID": "cours1.html#types-doutils-de-gestion-de-version",
    "href": "cours1.html#types-doutils-de-gestion-de-version",
    "title": "Cours 1 - Introduction au versionnage",
    "section": "",
    "text": "Il existe deux types d’outils de gestion de version : les outils de gestion de version dits centralisés et les outils de gestion de version dits décentralisés.\n\n\n\n\n\n\nRemarque\n\n\n\nDans ce cours nous allons utiliser l’outil de gestion de version décentralisé Git. Mais il est tout de même important de comprendre les différences entre les deux types d’outils.\n\n\n\n\nLes outils de gestion de version centralisés sont basés sur un modèle client-serveur. Ils utilisent un dépôt centralisé pour stocker les fichiers d’un projet et l’historique des modifications apportées à ces fichiers.\n\nLes développeurs travaillent sur une copie locale du dépôt centralisé.\nIls peuvent récupérer les modifications apportées au dépôt centralisé et les fusionner avec leur copie locale.\nIls peuvent également envoyer les modifications apportées à leur copie locale vers le dépôt centralisé.\n\nLes outils de gestion de version centralisés les plus populaires sont Subversion (SVN), Perforce, et ClearCase.\nLe graphique suivant illustre le fonctionnement d’un outil de gestion de version centralisé :\n\n\n\n\n\ngraph LR\n    A[Alice] -- Push --&gt; B((Dépôt centralisé))\n    B -- Pull --&gt; A\n    C[Bob] -- Push --&gt; B\n    B -- Pull --&gt; C\n\n\n\n\n\n\nAlice et Bob travaillent sur le même projet dont la gestion de version se fait par un outil de gestion de version centralisé\n\n\n\nAlice effectue un changement puis elle envoie ses modifications vers le dépôt central.\nLe dépôt central est mis à jour.\nBob récupère la dernière version du projet (qui intègre les changements d’Alice) en mettant à jour sa copie locale du dépôt central.\nSi il y a des conflits, Bob doit les résoudre manuellement avant de pouvoir envoyer ses modifications.\n\n\n\n\n\n\n\nAvantages\n\n\n\n\nContrôle centralisé : Un seul dépôt central offre un contrôle plus strict sur les modifications et les versions.\nVisibilité globale : Facilité de suivi des changements, historique global des versions et gestion des conflits simplifiée.\nCollaboration facilitée :Les équipes travaillent sur la même base de code, favorisant la collaboration et la cohérence du projet.\n\n\n\n\n\n\n\n\n\nInconvénients\n\n\n\n\nDépendance au serveur central : En cas de panne du serveur central, l’accès aux versions et la collaboration peuvent être perturbés.\nBranchements complexes : La gestion de branches peut être plus complexe, avec un risque accru de conflits lors des fusions.\nPerformance dépendante du réseau : L’accès et la performance peuvent être affectés si l’équipe travaille à distance ou avec une connexion lente.\nImpossibilité de travailler hors ligne : Les développeurs ne peuvent pas travailler hors ligne, ce qui peut être un problème pour les équipes distribuées.\n\n\n\n\n\n\n\nOn parle aussi d’outil de gestion distribué.\n\nIls utilisent un dépôt local pour stocker les fichiers d’un projet et l’historique des modifications apportées à ces fichiers.\nLes développeurs travaillent sur une copie locale du dépôt distant. Ils peuvent récupérer les modifications apportées au dépôt distant et les fusionner avec leur copie locale.\nIls peuvent également envoyer les modifications apportées à leur copie locale vers le dépôt distant.\n\nLes outils de gestion de version décentralisés les plus populaires sont Git et Mercurial\nLe graphique suivant illustre le fonctionnement d’un outil de gestion de version décentralisé :\n\n\n\n\n\n    graph LR\n        A[Dépôt local d'Alice] -- Push --&gt; B((Dépôt distant))\n        B -- Pull --&gt; A\n        C[Dépôt local de Bob] -- Push --&gt; B\n        B -- Pull --&gt; C\n        D[Alice] -- Commit --&gt; A\n        E[Bob] -- Commit --&gt; C\n\n\n\n\n\n\n\n\n\nAlice effectue un changement puis elle soumet ses modifications dans son dépôt local.\nElle pousse (push) ces modification vers le dépôt distant.\nLe dépôt distant est mis à jour.\nBob récupère la dernière version du projet (qui intègre les changements d’Alice) en mettant à jour son dépôt local par rapport au dépôt distant. (pull)\n\nC’est comme si chacun avait son propre dépôt centralisé.\n\n\n\n\n\n\nAvantages\n\n\n\n\nTravail en mode déconnecté : Les développeurs peuvent travailler en mode déconnecté sans être connectés en permanence à un serveur central.\nMeilleure sécurité : Les copies locales des fichiers sont stockées sur l’ordinateur du développeur, ce qui rend le système plus sûr et plus résistant aux attaques.\nMeilleure flexibilité : Les développeurs peuvent facilement créer des branches, expérimenter et fusionner des modifications sans affecter le code source principal.\nPerformances améliorées : Les opérations locales sont beaucoup plus rapides que les opérations de synchronisation avec un serveur central.\n\n\n\n\n\n\n\n\n\nInconvénients\n\n\n\n\nComplexité accrue : Les développeurs doivent apprendre à gérer les dépôts locaux et distants, ce qui peut être plus complexe.\nVisibilité limitée : Les développeurs ne peuvent pas voir les modifications apportées par d’autres développeurs tant qu’ils n’ont pas synchronisé leurs dépôts locaux avec le dépôt distant.\nGestion des conflits plus complexe : Les conflits peuvent être plus difficiles à gérer, car les développeurs doivent les résoudre localement avant de les pousser vers le dépôt distant."
  },
  {
    "objectID": "cours1.html#git",
    "href": "cours1.html#git",
    "title": "Cours 1 - Introduction au versionnage",
    "section": "",
    "text": "Dans ce cours, nous allons mettre en pratique les concepts de base du versionnage en utilisant l’outil de gestion de version décentralisé Git. Il est actuellement l’outil de gestion de version le plus utilisé, en particulier dans les projets open source, grâce à sa facilité d’utilisation, sa rapidité et sa flexibilité.\n\n\n\n\n\n\nNote\n\n\n\nGit a été créé en 2005 par Linus Torvalds, le créateur du noyau Linux. À l’époque, il cherchait un outil de gestion de version pour le développement du noyau Linux, mais n’était pas satisfait des outils existants tels que BitKeeper.\nTorvalds a donc décidé de créer son propre outil de gestion de version, en s’appuyant sur les principes de conception du noyau Linux.\nLe développement de Git a été principalement motivé par la nécessité de gérer efficacement le code source du noyau Linux, qui est un projet très complexe et en constante évolution avec des milliers de développeurs à travers le monde.\nAu fil des ans, Git est devenu de plus en plus populaire auprès des développeurs et des entreprises. En 2008, le projet Git a été adopté par la communauté open-source et est rapidement devenu un outil de gestion de version standard pour de nombreux projets open-source.\nAujourd’hui, Git est largement utilisé dans l’industrie du développement de logiciels pour la gestion de versions de code source, la collaboration en équipe, et l’intégration continue. Les plateformes d’hébergement de code source telles que GitHub, GitLab et Bitbucket sont devenues des outils incontournables pour les projets de développement de logiciels, en grande partie grâce à l’adoption massive de Git.\n\n\n\n\nIl existe de nombreuses manières différentes d’utiliser Git. Il y a les outils originaux en ligne de commande et il y a de nombreuses interfaces graphiques avec des capacités variables. La plupart des IDE récents intègre déjà l’utilisation d’outils gestion de version.\nDans ce cours, nous utiliserons Git en ligne de commande.\n\nTout d’abord, la ligne de commande est la seule interface qui permet de lancer toutes les commandes Git (la plupart des interfaces graphiques simplifient l’utilisation en ne couvrant qu’un sous-ensemble des fonctionnalités de Git).\nSi vous savez comment utiliser la version en ligne de commande, vous serez à même de comprendre comment fonctionne la version graphique, tandis que l’inverse n’est pas nécessairement vrai.\nDe plus, le choix d’un outil graphique est sujet à des goûts personnels, mais tous les utilisateurs auront les commandes installées et utilisables.\n\nToutes les commandes Git s’utilisent de la manière suivante:\ngit &lt;commande&gt; [options]\nIl faudra alors taper dans un terminal git suivi du nom de la commande et éventuellement suivis d’autres options que nous allons voir plus tard.\nPar exemple la commande init qui permet d’initialiser un dépôt Git et s’utilise de la manière suivante:\ngit init\n\n\n\n\n\n\nNote\n\n\n\n\nDans toute la suite de ce cours, surtout en TP, nous allons utiliser Git en ligne de commande. Pour ce faire, vous devez ouvrir un terminal sur votre machine.\n\nSi vous êtes sur Windows, vous pouvez utiliser Git Bash pour exécuter les commandes Git.\nSi vous êtes sur Linux ou Mac, vous pouvez utiliser le terminal intégré à votre système d’exploitation.\n\nDevant chaque commande, vous verrez le symbole $. Ce symbole représente le prompt de votre terminal. Vous ne devez pas le copier lorsque vous exécutez les commandes Git.\nLes lignes de commandes précédées du symbole # sont des commentaires. Vous ne devez pas les copier lorsque vous exécutez les commandes.\n\n\n\n\n\n\nUne fois que vous avez créé un dépôt Git, l’outil va créer un répertoire .git qui contient tous les fichiers nécessaires au fonctionnement de Git. Ce répertoire est appelé dépôt Git ou dépôt local. Il est très important de ne pas modifier ou supprimer ce répertoire.\nGit va alors retracer l’historique des modifications apportées aux fichiers du projet en travaillant avec trois zones différentes:\n\nla zone de travail (working directory)\n\nc’est le répertoire dans lequel sont stockés physiquement vos fichiers. C’est le répertoire dans lequel vous travaillez.\n\nla zone d’index (staging area)\n\nc’est une zone intermédiaire entre la zone de travail et la zone de dépôt.\nelle permet de marquer les modifications à envoyer lors du prochain commit.\nelle est matérialisée dans .git/index\n\nla zone de dépôt (git repository)\n\nc’est le répertoire dans lequel sont stockés les fichiers de votre projet tels qu’ils étaient lors de votre dernier commit.\nDans ce répertoire, Git stocke l’historique des modifications apportées à votre projet.\n\n\nLes différentes commandes Git permettent de passer d’une zone à une autre. On peut voir le dépôt Git comme étant une base de données qui garde de manière compressée toutes les versions (que vous voulez que Git conserve) de votre projet. Le diagramme suivant montre comment passer un fichier d’une zone à une autre.\n\n\n\n\n\nstateDiagram-v2\n    s1 : Git repository\n    s2 : Staging area\n    s3 : Working directory\n    s1 --&gt; s2 : git reset\n    s2 --&gt; s1 : git commit\n    s2 --&gt; s3 : git checkout\n    s3 --&gt; s2 : git add\n\n\n\n\n\n\nLa commande git status permet savoir quels fichiers sont différents d’une zone à une autre.\n$ git status\n# On branch main\n# Changes to be committed:\n#   (use \"git reset HEAD ...\" to unstage)\n#\n#   modified:   accounts/forms.py\n#   modified:   accounts/models.py\n#\n# Changes not staged for commit:\n#   (use \"git add ...\" to update what will be committed)\n#   (use \"git checkout -- ...\" to discard changes in working directory)\n#\n#   modified:   accounts/urls.py\n#   modified:   accounts/views.py\nIci, la réponse de git status indique par exemple que les fichiers:\n\naccounts/forms.py et accounts/models.py sont indexés dans la zone de staging et attendent d’être ajouté dans le dépôt.\naccounts/urls.py et accounts/views.py ne sont pas encore dans la zone de staging et attendent d’y être ajoutés.\n\nLe processus usuel est donc le suivant:\n\nOn crée/modifie un fichier dans la zone de travail\nOn l’ajoute dans la zone d’index avec git add.\nEnsuite, on soumets les modifications apportés au dépôt git avec git commit.\n\n\n\n\nVoici les commandes de base de Git dans diverses situations telles qu’elles sont listées dans l’accueil de l’outil :\nDémarrer un dépôt Git\n\nclone Cloner un dépôt dans un nouveau répertoire\ninit Créer un dépôt Git vide ou réinitialiser un existant\n\nTavailler sur la modification actuelle\n\nadd Ajouter le contenu de fichiers dans l’index\n\nadd -u ajouter tous les fichiers modifiés et supprimés (mais pas les “untracked”)\n\nmv Déplacer ou renommer un fichier, un répertoire, ou un lien symbolique\nrestore Restaurer des fichiers\nrm Supprimer des fichiers de la copie de travail et de l’index\n\nExaminer l’historique et l’état du dépôt\n\ndiff Afficher les changements entre les commits\nlog Afficher l’historique des commits\nstatus Afficher l’état de la répertoire de travail\n\nAgrandir, marquer et modifier votre historique\n\nbranch Lister, créer ou supprimer des branches\ncommit Enregistrer les modifications dans le dépôt\nmerge Fusionner deux ou plusieurs historiques de développement ensemble\nrebase Déplacer un ensemble de commits vers un autre point de base\nreset Réinitialiser la HEAD courante à l’état spécifié\nswitch Basculer de branche\n\nCollaborer\n\nfetch Télécharger les objets et références depuis un autre dépôt\npull Rapatrier et intégrer un historique depuis un dépôt distant\npush Pousser l’histoire local vers un dépôt distant\n\nSi l’on ne se souvient pas de toutes les commandes\n\nhelp Affiche l’aide\n\nUn aide mémoire est également à votre disposition ici.\n\n\n\n\n\n\nTip\n\n\n\nDans le premier TP associé à ce cours, nous allons installer, configurer Git et faire nos premiers pas avec l’outil."
  }
]